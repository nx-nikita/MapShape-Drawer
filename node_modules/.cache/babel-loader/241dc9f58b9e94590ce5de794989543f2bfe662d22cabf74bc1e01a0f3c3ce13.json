{"ast":null,"code":"// index.ts\nimport { bbox as turfBBox } from \"@turf/bbox\";\nimport { getCoords, getGeom } from \"@turf/invariant\";\nimport { polygon, multiPolygon, lineString } from \"@turf/helpers\";\nimport { clone } from \"@turf/clone\";\nfunction lineToPolygon(lines) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _a, _b, _c;\n  var properties = options.properties;\n  var autoComplete = (_a = options.autoComplete) != null ? _a : true;\n  var orderCoords = (_b = options.orderCoords) != null ? _b : true;\n  var mutate = (_c = options.mutate) != null ? _c : false;\n  if (!mutate) {\n    lines = clone(lines);\n  }\n  switch (lines.type) {\n    case \"FeatureCollection\":\n      var coords = [];\n      lines.features.forEach(function (line) {\n        coords.push(getCoords(lineStringToPolygon(line, {}, autoComplete, orderCoords)));\n      });\n      return multiPolygon(coords, properties);\n    default:\n      return lineStringToPolygon(lines, properties, autoComplete, orderCoords);\n  }\n}\nfunction lineStringToPolygon(line, properties, autoComplete, orderCoords) {\n  properties = properties ? properties : line.type === \"Feature\" ? line.properties : {};\n  var geom = getGeom(line);\n  var coords = geom.coordinates;\n  var type = geom.type;\n  if (!coords.length) throw new Error(\"line must contain coordinates\");\n  switch (type) {\n    case \"LineString\":\n      if (autoComplete) coords = autoCompleteCoords(coords);\n      return polygon([coords], properties);\n    case \"MultiLineString\":\n      var multiCoords = [];\n      var largestArea = 0;\n      coords.forEach(function (coord) {\n        if (autoComplete) coord = autoCompleteCoords(coord);\n        if (orderCoords) {\n          var area = calculateArea(turfBBox(lineString(coord)));\n          if (area > largestArea) {\n            multiCoords.unshift(coord);\n            largestArea = area;\n          } else multiCoords.push(coord);\n        } else {\n          multiCoords.push(coord);\n        }\n      });\n      return polygon(multiCoords, properties);\n    default:\n      throw new Error(\"geometry type \" + type + \" is not supported\");\n  }\n}\nfunction autoCompleteCoords(coords) {\n  var first = coords[0];\n  var x1 = first[0];\n  var y1 = first[1];\n  var last = coords[coords.length - 1];\n  var x2 = last[0];\n  var y2 = last[1];\n  if (x1 !== x2 || y1 !== y2) {\n    coords.push(first);\n  }\n  return coords;\n}\nfunction calculateArea(bbox) {\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n  return Math.abs(west - east) * Math.abs(south - north);\n}\nvar index_default = lineToPolygon;\nexport { index_default as default, lineToPolygon };","map":{"version":3,"names":["bbox","turfBBox","getCoords","getGeom","polygon","multiPolygon","lineString","clone","lineToPolygon","lines","options","arguments","length","undefined","_a","_b","_c","properties","autoComplete","orderCoords","mutate","type","coords","features","forEach","line","push","lineStringToPolygon","geom","coordinates","Error","autoCompleteCoords","multiCoords","largestArea","coord","area","calculateArea","unshift","first","x1","y1","last","x2","y2","west","south","east","north","Math","abs","index_default"],"sources":["C:\\Users\\HP\\map-drawing-app\\node_modules\\@turf\\line-to-polygon\\index.ts"],"sourcesContent":["import {\n  Feature,\n  FeatureCollection,\n  MultiLineString,\n  LineString,\n  GeoJsonProperties,\n  BBox,\n  Position,\n} from \"geojson\";\nimport { bbox as turfBBox } from \"@turf/bbox\";\nimport { getCoords, getGeom } from \"@turf/invariant\";\nimport { polygon, multiPolygon, lineString } from \"@turf/helpers\";\nimport { clone } from \"@turf/clone\";\n\n/**\n * Converts (Multi)LineString(s) to Polygon(s).\n *\n * @function\n * @param {FeatureCollection|Feature<LineString|MultiLineString>} lines Features to convert\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] translates GeoJSON properties to Feature\n * @param {boolean} [options.autoComplete=true] auto complete linestrings (matches first & last coordinates)\n * @param {boolean} [options.orderCoords=true] sorts linestrings to place outer ring at the first position of the coordinates\n * @param {boolean} [options.mutate=false] mutate the original linestring using autoComplete (matches first & last coordinates)\n * @returns {Feature<Polygon|MultiPolygon>} converted to Polygons\n * @example\n * var line = turf.lineString([[125, -30], [145, -30], [145, -20], [125, -20], [125, -30]]);\n *\n * var polygon = turf.lineToPolygon(line);\n *\n * //addToMap\n * var addToMap = [polygon];\n */\nfunction lineToPolygon<G extends LineString | MultiLineString>(\n  lines: Feature<G> | FeatureCollection<G> | G,\n  options: {\n    properties?: GeoJsonProperties;\n    autoComplete?: boolean;\n    orderCoords?: boolean;\n    mutate?: boolean;\n  } = {}\n) {\n  // Optional parameters\n  var properties = options.properties;\n  var autoComplete = options.autoComplete ?? true;\n  var orderCoords = options.orderCoords ?? true;\n  var mutate = options.mutate ?? false;\n\n  if (!mutate) {\n    lines = clone(lines);\n  }\n\n  switch (lines.type) {\n    case \"FeatureCollection\":\n      var coords: number[][][][] = [];\n      lines.features.forEach(function (line) {\n        coords.push(\n          getCoords(lineStringToPolygon(line, {}, autoComplete, orderCoords))\n        );\n      });\n      return multiPolygon(coords, properties);\n    default:\n      return lineStringToPolygon(lines, properties, autoComplete, orderCoords);\n  }\n}\n\n/**\n * LineString to Polygon\n *\n * @private\n * @param {Feature<LineString|MultiLineString>} line line\n * @param {Object} [properties] translates GeoJSON properties to Feature\n * @param {boolean} [autoComplete=true] auto complete linestrings\n * @param {boolean} [orderCoords=true] sorts linestrings to place outer ring at the first position of the coordinates\n * @returns {Feature<Polygon>} line converted to Polygon\n */\nfunction lineStringToPolygon<G extends LineString | MultiLineString>(\n  line: Feature<G> | G,\n  properties: GeoJsonProperties | undefined,\n  autoComplete: boolean,\n  orderCoords: boolean\n) {\n  properties = properties\n    ? properties\n    : line.type === \"Feature\"\n      ? line.properties\n      : {};\n  var geom = getGeom(line);\n  var coords: Position[] | Position[][] = geom.coordinates;\n  var type = geom.type;\n\n  if (!coords.length) throw new Error(\"line must contain coordinates\");\n\n  switch (type) {\n    case \"LineString\":\n      if (autoComplete) coords = autoCompleteCoords(coords as Position[]);\n      return polygon([coords as Position[]], properties);\n    case \"MultiLineString\":\n      var multiCoords: number[][][] = [];\n      var largestArea = 0;\n\n      (coords as Position[][]).forEach(function (coord) {\n        if (autoComplete) coord = autoCompleteCoords(coord);\n\n        // Largest LineString to be placed in the first position of the coordinates array\n        if (orderCoords) {\n          var area = calculateArea(turfBBox(lineString(coord)));\n          if (area > largestArea) {\n            multiCoords.unshift(coord);\n            largestArea = area;\n          } else multiCoords.push(coord);\n        } else {\n          multiCoords.push(coord);\n        }\n      });\n      return polygon(multiCoords, properties);\n    default:\n      throw new Error(\"geometry type \" + type + \" is not supported\");\n  }\n}\n\n/**\n * Auto Complete Coords - matches first & last coordinates\n *\n * @private\n * @param {Array<Array<number>>} coords Coordinates\n * @returns {Array<Array<number>>} auto completed coordinates\n */\nfunction autoCompleteCoords(coords: Position[]) {\n  var first = coords[0];\n  var x1 = first[0];\n  var y1 = first[1];\n  var last = coords[coords.length - 1];\n  var x2 = last[0];\n  var y2 = last[1];\n  if (x1 !== x2 || y1 !== y2) {\n    coords.push(first);\n  }\n  return coords;\n}\n\n/**\n * area - quick approximate area calculation (used to sort)\n *\n * @private\n * @param {Array<number>} bbox BBox [west, south, east, north]\n * @returns {number} very quick area calculation\n */\nfunction calculateArea(bbox: BBox) {\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n  return Math.abs(west - east) * Math.abs(south - north);\n}\n\nexport { lineToPolygon };\nexport default lineToPolygon;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}