{"ast":null,"code":"import * as turf from \"@turf/turf\";\n\n/* --------------------------------------------------\r\n   STEP 1: FULL ENCLOSURE CHECK (INTERVIEW MUST)\r\n   - new polygon existing ke andar ho\r\n   - ya existing polygon new ke andar ho\r\n-------------------------------------------------- */\nexport const isFullyInside = (newPoly, existingPoly) => {\n  try {\n    return turf.booleanContains(existingPoly, newPoly) || turf.booleanContains(newPoly, existingPoly);\n  } catch {\n    return false;\n  }\n};\n\n/* --------------------------------------------------\r\n   STEP 2: SAFE INTERSECTION CHECK\r\n-------------------------------------------------- */\nexport const hasIntersection = (poly1, poly2) => {\n  try {\n    return turf.booleanIntersects(poly1, poly2);\n  } catch {\n    return false;\n  }\n};\n\n/* --------------------------------------------------\r\n   STEP 3: AUTO-TRIM PARTIAL OVERLAP ONLY\r\n   ✔ Partial overlap → trim\r\n   ❌ Full overlap → null\r\n   ❌ Tiny sliver → ignore\r\n-------------------------------------------------- */\nexport const trimPolygon = (newPoly, existingPoly) => {\n  try {\n    /* ---- A. INTERSECTION (Turf v6 way) ---- */\n    const intersection = turf.intersect(turf.featureCollection([newPoly, existingPoly]));\n\n    // No overlap → return original\n    if (!intersection) return newPoly;\n\n    // Ignore very tiny touch\n    if (turf.area(intersection) < 1) return newPoly;\n\n    /* ---- B. DIFFERENCE (Turf v6 way) ---- */\n    const diff = turf.difference(turf.featureCollection([newPoly, existingPoly]));\n\n    // Fully eaten → reject\n    if (!diff) return null;\n\n    // Very small polygon → reject\n    if (turf.area(diff) < 1) return null;\n    return diff;\n  } catch (error) {\n    console.warn(\"trimPolygon failed:\", error);\n    return null;\n  }\n};","map":{"version":3,"names":["turf","isFullyInside","newPoly","existingPoly","booleanContains","hasIntersection","poly1","poly2","booleanIntersects","trimPolygon","intersection","intersect","featureCollection","area","diff","difference","error","console","warn"],"sources":["C:/Users/HP/map-drawing-app/-Shapes-Drawer/src/utils/geometry.ts"],"sourcesContent":["import { Feature, Polygon } from \"geojson\";\r\nimport * as turf from \"@turf/turf\";\r\n\r\n/* --------------------------------------------------\r\n   STEP 1: FULL ENCLOSURE CHECK (INTERVIEW MUST)\r\n   - new polygon existing ke andar ho\r\n   - ya existing polygon new ke andar ho\r\n-------------------------------------------------- */\r\nexport const isFullyInside = (\r\n  newPoly: Feature<Polygon>,\r\n  existingPoly: Feature<Polygon>\r\n): boolean => {\r\n  try {\r\n    return (\r\n      turf.booleanContains(existingPoly, newPoly) ||\r\n      turf.booleanContains(newPoly, existingPoly)\r\n    );\r\n  } catch {\r\n    return false;\r\n  }\r\n};\r\n\r\n/* --------------------------------------------------\r\n   STEP 2: SAFE INTERSECTION CHECK\r\n-------------------------------------------------- */\r\nexport const hasIntersection = (\r\n  poly1: Feature<Polygon>,\r\n  poly2: Feature<Polygon>\r\n): boolean => {\r\n  try {\r\n    return turf.booleanIntersects(poly1, poly2);\r\n  } catch {\r\n    return false;\r\n  }\r\n};\r\n\r\n/* --------------------------------------------------\r\n   STEP 3: AUTO-TRIM PARTIAL OVERLAP ONLY\r\n   ✔ Partial overlap → trim\r\n   ❌ Full overlap → null\r\n   ❌ Tiny sliver → ignore\r\n-------------------------------------------------- */\r\nexport const trimPolygon = (\r\n  newPoly: Feature<Polygon>,\r\n  existingPoly: Feature<Polygon>\r\n): Feature<Polygon> | null => {\r\n  try {\r\n    /* ---- A. INTERSECTION (Turf v6 way) ---- */\r\n    const intersection = turf.intersect(\r\n      turf.featureCollection([newPoly, existingPoly])\r\n    );\r\n\r\n    // No overlap → return original\r\n    if (!intersection) return newPoly;\r\n\r\n    // Ignore very tiny touch\r\n    if (turf.area(intersection) < 1) return newPoly;\r\n\r\n    /* ---- B. DIFFERENCE (Turf v6 way) ---- */\r\n    const diff = turf.difference(\r\n      turf.featureCollection([newPoly, existingPoly])\r\n    ) as Feature<Polygon> | null;\r\n\r\n    // Fully eaten → reject\r\n    if (!diff) return null;\r\n\r\n    // Very small polygon → reject\r\n    if (turf.area(diff) < 1) return null;\r\n\r\n    return diff;\r\n  } catch (error) {\r\n    console.warn(\"trimPolygon failed:\", error);\r\n    return null;\r\n  }\r\n};\r\n"],"mappings":"AACA,OAAO,KAAKA,IAAI,MAAM,YAAY;;AAElC;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,aAAa,GAAGA,CAC3BC,OAAyB,EACzBC,YAA8B,KAClB;EACZ,IAAI;IACF,OACEH,IAAI,CAACI,eAAe,CAACD,YAAY,EAAED,OAAO,CAAC,IAC3CF,IAAI,CAACI,eAAe,CAACF,OAAO,EAAEC,YAAY,CAAC;EAE/C,CAAC,CAAC,MAAM;IACN,OAAO,KAAK;EACd;AACF,CAAC;;AAED;AACA;AACA;AACA,OAAO,MAAME,eAAe,GAAGA,CAC7BC,KAAuB,EACvBC,KAAuB,KACX;EACZ,IAAI;IACF,OAAOP,IAAI,CAACQ,iBAAiB,CAACF,KAAK,EAAEC,KAAK,CAAC;EAC7C,CAAC,CAAC,MAAM;IACN,OAAO,KAAK;EACd;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAME,WAAW,GAAGA,CACzBP,OAAyB,EACzBC,YAA8B,KACF;EAC5B,IAAI;IACF;IACA,MAAMO,YAAY,GAAGV,IAAI,CAACW,SAAS,CACjCX,IAAI,CAACY,iBAAiB,CAAC,CAACV,OAAO,EAAEC,YAAY,CAAC,CAChD,CAAC;;IAED;IACA,IAAI,CAACO,YAAY,EAAE,OAAOR,OAAO;;IAEjC;IACA,IAAIF,IAAI,CAACa,IAAI,CAACH,YAAY,CAAC,GAAG,CAAC,EAAE,OAAOR,OAAO;;IAE/C;IACA,MAAMY,IAAI,GAAGd,IAAI,CAACe,UAAU,CAC1Bf,IAAI,CAACY,iBAAiB,CAAC,CAACV,OAAO,EAAEC,YAAY,CAAC,CAChD,CAA4B;;IAE5B;IACA,IAAI,CAACW,IAAI,EAAE,OAAO,IAAI;;IAEtB;IACA,IAAId,IAAI,CAACa,IAAI,CAACC,IAAI,CAAC,GAAG,CAAC,EAAE,OAAO,IAAI;IAEpC,OAAOA,IAAI;EACb,CAAC,CAAC,OAAOE,KAAK,EAAE;IACdC,OAAO,CAACC,IAAI,CAAC,qBAAqB,EAAEF,KAAK,CAAC;IAC1C,OAAO,IAAI;EACb;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}