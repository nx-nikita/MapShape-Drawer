{"ast":null,"code":"import * as turf from \"@turf/turf\";\nimport booleanContains from \"@turf/boolean-contains\";\nimport booleanIntersects from \"@turf/boolean-intersects\";\n\n/**\r\n * ❌ Reject only FULL overlap / full contain\r\n * ✅ Allow partial overlap (for auto-trim)\r\n */\nexport const applyPolygonRules = (newFeature, existing) => {\n  for (const old of existing) {\n    if (!old.geometry) continue;\n\n    // ❌ Completely inside OR fully covered\n    if (booleanContains(old, newFeature) || booleanContains(newFeature, old)) {\n      return null;\n    }\n  }\n  return newFeature;\n};\n\n/**\r\n * ✅ Check if overlap exists\r\n */\nexport const hasOverlap = (newFeature, features) => {\n  for (const f of features) {\n    if (booleanIntersects(newFeature, f)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\r\n * ✂️ Auto trim polygon ONLY when overlap exists\r\n */\nexport const trimPolygon = (newPoly, existingPoly) => {\n  try {\n    // ✅ No intersection → return original polygon\n    if (!booleanIntersects(newPoly, existingPoly)) {\n      return newPoly;\n    }\n    const diff = turf.difference(newPoly, existingPoly);\n    if (!diff) return null;\n\n    // Polygon\n    if (diff.geometry.type === \"Polygon\") {\n      return diff;\n    }\n\n    // MultiPolygon → pick largest\n    if (diff.geometry.type === \"MultiPolygon\") {\n      const largest = diff.geometry.coordinates.reduce((a, b) => turf.area(turf.polygon(a)) > turf.area(turf.polygon(b)) ? a : b);\n      return turf.polygon(largest);\n    }\n    return null;\n  } catch (err) {\n    console.warn(\"Auto-trim failed:\", err);\n    return null;\n  }\n};","map":{"version":3,"names":["turf","booleanContains","booleanIntersects","applyPolygonRules","newFeature","existing","old","geometry","hasOverlap","features","f","trimPolygon","newPoly","existingPoly","diff","difference","type","largest","coordinates","reduce","a","b","area","polygon","err","console","warn"],"sources":["C:/Users/HP/map-drawing-app/-Shapes-Drawer/src/utils/geometry.ts"],"sourcesContent":["import { Feature, Polygon } from \"geojson\";\r\nimport * as turf from \"@turf/turf\";\r\nimport booleanContains from \"@turf/boolean-contains\";\r\nimport booleanIntersects from \"@turf/boolean-intersects\";\r\n\r\n/**\r\n * ❌ Reject only FULL overlap / full contain\r\n * ✅ Allow partial overlap (for auto-trim)\r\n */\r\nexport const applyPolygonRules = (\r\n  newFeature: Feature<Polygon>,\r\n  existing: Feature<Polygon>[]\r\n): Feature<Polygon> | null => {\r\n  for (const old of existing) {\r\n    if (!old.geometry) continue;\r\n\r\n    // ❌ Completely inside OR fully covered\r\n    if (\r\n      booleanContains(old as any, newFeature as any) ||\r\n      booleanContains(newFeature as any, old as any)\r\n    ) {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  return newFeature;\r\n};\r\n\r\n/**\r\n * ✅ Check if overlap exists\r\n */\r\nexport const hasOverlap = (\r\n  newFeature: Feature<Polygon>,\r\n  features: Feature<Polygon>[]\r\n): boolean => {\r\n  for (const f of features) {\r\n    if (booleanIntersects(newFeature as any, f as any)) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * ✂️ Auto trim polygon ONLY when overlap exists\r\n */\r\nexport const trimPolygon = (\r\n  newPoly: Feature<Polygon>,\r\n  existingPoly: Feature<Polygon>\r\n): Feature<Polygon> | null => {\r\n  try {\r\n    // ✅ No intersection → return original polygon\r\n    if (!booleanIntersects(newPoly as any, existingPoly as any)) {\r\n      return newPoly;\r\n    }\r\n\r\n    const diff = turf.difference(\r\n      newPoly as any,\r\n      existingPoly as any\r\n    );\r\n\r\n    if (!diff) return null;\r\n\r\n    // Polygon\r\n    if (diff.geometry.type === \"Polygon\") {\r\n      return diff as Feature<Polygon>;\r\n    }\r\n\r\n    // MultiPolygon → pick largest\r\n    if (diff.geometry.type === \"MultiPolygon\") {\r\n      const largest = diff.geometry.coordinates.reduce((a, b) =>\r\n        turf.area(turf.polygon(a)) > turf.area(turf.polygon(b)) ? a : b\r\n      );\r\n      return turf.polygon(largest) as Feature<Polygon>;\r\n    }\r\n\r\n    return null;\r\n  } catch (err) {\r\n    console.warn(\"Auto-trim failed:\", err);\r\n    return null;\r\n  }\r\n};\r\n"],"mappings":"AACA,OAAO,KAAKA,IAAI,MAAM,YAAY;AAClC,OAAOC,eAAe,MAAM,wBAAwB;AACpD,OAAOC,iBAAiB,MAAM,0BAA0B;;AAExD;AACA;AACA;AACA;AACA,OAAO,MAAMC,iBAAiB,GAAGA,CAC/BC,UAA4B,EAC5BC,QAA4B,KACA;EAC5B,KAAK,MAAMC,GAAG,IAAID,QAAQ,EAAE;IAC1B,IAAI,CAACC,GAAG,CAACC,QAAQ,EAAE;;IAEnB;IACA,IACEN,eAAe,CAACK,GAAG,EAASF,UAAiB,CAAC,IAC9CH,eAAe,CAACG,UAAU,EAASE,GAAU,CAAC,EAC9C;MACA,OAAO,IAAI;IACb;EACF;EAEA,OAAOF,UAAU;AACnB,CAAC;;AAED;AACA;AACA;AACA,OAAO,MAAMI,UAAU,GAAGA,CACxBJ,UAA4B,EAC5BK,QAA4B,KAChB;EACZ,KAAK,MAAMC,CAAC,IAAID,QAAQ,EAAE;IACxB,IAAIP,iBAAiB,CAACE,UAAU,EAASM,CAAQ,CAAC,EAAE;MAClD,OAAO,IAAI;IACb;EACF;EACA,OAAO,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA,OAAO,MAAMC,WAAW,GAAGA,CACzBC,OAAyB,EACzBC,YAA8B,KACF;EAC5B,IAAI;IACF;IACA,IAAI,CAACX,iBAAiB,CAACU,OAAO,EAASC,YAAmB,CAAC,EAAE;MAC3D,OAAOD,OAAO;IAChB;IAEA,MAAME,IAAI,GAAGd,IAAI,CAACe,UAAU,CAC1BH,OAAO,EACPC,YACF,CAAC;IAED,IAAI,CAACC,IAAI,EAAE,OAAO,IAAI;;IAEtB;IACA,IAAIA,IAAI,CAACP,QAAQ,CAACS,IAAI,KAAK,SAAS,EAAE;MACpC,OAAOF,IAAI;IACb;;IAEA;IACA,IAAIA,IAAI,CAACP,QAAQ,CAACS,IAAI,KAAK,cAAc,EAAE;MACzC,MAAMC,OAAO,GAAGH,IAAI,CAACP,QAAQ,CAACW,WAAW,CAACC,MAAM,CAAC,CAACC,CAAC,EAAEC,CAAC,KACpDrB,IAAI,CAACsB,IAAI,CAACtB,IAAI,CAACuB,OAAO,CAACH,CAAC,CAAC,CAAC,GAAGpB,IAAI,CAACsB,IAAI,CAACtB,IAAI,CAACuB,OAAO,CAACF,CAAC,CAAC,CAAC,GAAGD,CAAC,GAAGC,CAChE,CAAC;MACD,OAAOrB,IAAI,CAACuB,OAAO,CAACN,OAAO,CAAC;IAC9B;IAEA,OAAO,IAAI;EACb,CAAC,CAAC,OAAOO,GAAG,EAAE;IACZC,OAAO,CAACC,IAAI,CAAC,mBAAmB,EAAEF,GAAG,CAAC;IACtC,OAAO,IAAI;EACb;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}