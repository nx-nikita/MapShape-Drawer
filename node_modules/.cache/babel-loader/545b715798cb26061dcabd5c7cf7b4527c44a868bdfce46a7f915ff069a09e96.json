{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\n// index.ts\nimport { bbox } from \"@turf/bbox\";\nimport { area } from \"@turf/area\";\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { explode } from \"@turf/explode\";\nimport { collectionOf as collectionOf2 } from \"@turf/invariant\";\nimport { polygon, multiPolygon, featureCollection, isObject as isObject2 } from \"@turf/helpers\";\n\n// lib/grid-to-matrix.js\nimport { getCoords, collectionOf } from \"@turf/invariant\";\nimport { featureEach } from \"@turf/meta\";\nimport { isObject } from \"@turf/helpers\";\nfunction gridToMatrix(grid, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var zProperty = options.zProperty || \"elevation\";\n  var flip = options.flip;\n  var flags = options.flags;\n  collectionOf(grid, \"Point\", \"input must contain Points\");\n  var pointsMatrix = sortPointsByLatLng(grid, flip);\n  var matrix = [];\n  for (var r = 0; r < pointsMatrix.length; r++) {\n    var pointRow = pointsMatrix[r];\n    var row = [];\n    for (var c = 0; c < pointRow.length; c++) {\n      var point = pointRow[c];\n      if (point.properties[zProperty]) row.push(point.properties[zProperty]);else row.push(0);\n      if (flags === true) point.properties.matrixPosition = [r, c];\n    }\n    matrix.push(row);\n  }\n  return matrix;\n}\nfunction sortPointsByLatLng(points, flip) {\n  var pointsByLatitude = {};\n  featureEach(points, function (point) {\n    var lat = getCoords(point)[1];\n    if (!pointsByLatitude[lat]) pointsByLatitude[lat] = [];\n    pointsByLatitude[lat].push(point);\n  });\n  var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function (lat) {\n    var row = pointsByLatitude[lat];\n    var rowOrderedByLongitude = row.sort(function (a, b) {\n      return getCoords(a)[0] - getCoords(b)[0];\n    });\n    return rowOrderedByLongitude;\n  });\n  var pointMatrix = orderedRowsByLatitude.sort(function (a, b) {\n    if (flip) return getCoords(a[0])[1] - getCoords(b[0])[1];else return getCoords(b[0])[1] - getCoords(a[0])[1];\n  });\n  return pointMatrix;\n}\n\n// index.ts\nfunction isobands(pointGrid, breaks, options) {\n  options = options || {};\n  if (!isObject2(options)) throw new Error(\"options is invalid\");\n  const zProperty = options.zProperty || \"elevation\";\n  const commonProperties = options.commonProperties || {};\n  const breaksProperties = options.breaksProperties || [];\n  collectionOf2(pointGrid, \"Point\", \"Input must contain Points\");\n  if (!breaks) throw new Error(\"breaks is required\");\n  if (!Array.isArray(breaks)) throw new Error(\"breaks is not an Array\");\n  if (!isObject2(commonProperties)) throw new Error(\"commonProperties is not an Object\");\n  if (!Array.isArray(breaksProperties)) throw new Error(\"breaksProperties is not an Array\");\n  const matrix = gridToMatrix(pointGrid, {\n    zProperty,\n    flip: true\n  });\n  const dx = matrix[0].length;\n  if (matrix.length < 2 || dx < 2) {\n    throw new Error(\"Matrix of points must be at least 2x2\");\n  }\n  for (let i = 1; i < matrix.length; i++) {\n    if (matrix[i].length !== dx) {\n      throw new Error(\"Matrix of points is not uniform in the x dimension\");\n    }\n  }\n  let contours = createContourLines(matrix, breaks, zProperty);\n  contours = rescaleContours(contours, matrix, pointGrid);\n  const multipolygons = contours.map((contour, index) => {\n    if (breaksProperties[index] && !isObject2(breaksProperties[index])) {\n      throw new Error(\"Each mappedProperty is required to be an Object\");\n    }\n    const contourProperties = __spreadValues(__spreadValues({}, commonProperties), breaksProperties[index]);\n    contourProperties[zProperty] = contour[zProperty];\n    const multiP = multiPolygon(contour.groupedRings, contourProperties);\n    return multiP;\n  });\n  return featureCollection(multipolygons);\n}\nfunction createContourLines(matrix, breaks, property) {\n  const contours = [];\n  let prevSegments;\n  for (let i = 1; i < breaks.length; i++) {\n    if (i === 1) {\n      prevSegments = getSegments(matrix, +breaks[0]);\n    }\n    const upperBand = +breaks[i];\n    const lowerBand = +breaks[i - 1];\n    const segments = getSegments(matrix, upperBand);\n    const reverseSegments = segments.map(segment =>\n    // note that we (in-place) reverse the array result of .map and not the original segment itself.\n    segment.map(pos => [pos[0], pos[1]]).reverse());\n    const rings = assembleRings(prevSegments.concat(reverseSegments), matrix);\n    const orderedRings = orderByArea(rings);\n    const polygons = groupNestedRings(orderedRings);\n    if (polygons.length === 0 && matrix[0][0] < upperBand && matrix[0][0] >= lowerBand) {\n      const dx = matrix[0].length;\n      const dy = matrix.length;\n      polygons.push([[[0, 0], [dx - 1, 0], [dx - 1, dy - 1], [0, dy - 1], [0, 0]]]);\n    }\n    contours.push({\n      groupedRings: polygons,\n      [property]: lowerBand + \"-\" + upperBand\n    });\n    prevSegments = segments;\n  }\n  return contours;\n}\nfunction getSegments(matrix, threshold) {\n  const segments = [];\n  const dx = matrix[0].length;\n  const dy = matrix.length;\n  for (let y = 0; y < dy - 1; y++) {\n    for (let x = 0; x < dx - 1; x++) {\n      const tr = matrix[y + 1][x + 1];\n      const br = matrix[y][x + 1];\n      const bl = matrix[y][x];\n      const tl = matrix[y + 1][x];\n      let grid = (tl >= threshold ? 8 : 0) | (tr >= threshold ? 4 : 0) | (br >= threshold ? 2 : 0) | (bl >= threshold ? 1 : 0);\n      switch (grid) {\n        case 0:\n          continue;\n        case 1:\n          segments.push([[x + frac(bl, br), y], [x, y + frac(bl, tl)]]);\n          break;\n        case 2:\n          segments.push([[x + 1, y + frac(br, tr)], [x + frac(bl, br), y]]);\n          break;\n        case 3:\n          segments.push([[x + 1, y + frac(br, tr)], [x, y + frac(bl, tl)]]);\n          break;\n        case 4:\n          segments.push([[x + frac(tl, tr), y + 1], [x + 1, y + frac(br, tr)]]);\n          break;\n        case 5:\n          {\n            const avg = (tl + tr + br + bl) / 4;\n            const above = avg >= threshold;\n            if (above) {\n              segments.push([[x + frac(tl, tr), y + 1], [x, y + frac(bl, tl)]], [[x + frac(bl, br), y], [x + 1, y + frac(br, tr)]]);\n            } else {\n              segments.push([[x + frac(tl, tr), y + 1], [x + 1, y + frac(br, tr)]], [[x + frac(bl, br), y], [x, y + frac(bl, tl)]]);\n            }\n            break;\n          }\n        case 6:\n          segments.push([[x + frac(tl, tr), y + 1], [x + frac(bl, br), y]]);\n          break;\n        case 7:\n          segments.push([[x + frac(tl, tr), y + 1], [x, y + frac(bl, tl)]]);\n          break;\n        case 8:\n          segments.push([[x, y + frac(bl, tl)], [x + frac(tl, tr), y + 1]]);\n          break;\n        case 9:\n          segments.push([[x + frac(bl, br), y], [x + frac(tl, tr), y + 1]]);\n          break;\n        case 10:\n          {\n            const avg = (tl + tr + br + bl) / 4;\n            const above = avg >= threshold;\n            if (above) {\n              segments.push([[x, y + frac(bl, tl)], [x + frac(bl, br), y]], [[x + 1, y + frac(br, tr)], [x + frac(tl, tr), y + 1]]);\n            } else {\n              segments.push([[x, y + frac(bl, tl)], [x + frac(tl, tr), y + 1]], [[x + 1, y + frac(br, tr)], [x + frac(bl, br), y]]);\n            }\n            break;\n          }\n        case 11:\n          segments.push([[x + 1, y + frac(br, tr)], [x + frac(tl, tr), y + 1]]);\n          break;\n        case 12:\n          segments.push([[x, y + frac(bl, tl)], [x + 1, y + frac(br, tr)]]);\n          break;\n        case 13:\n          segments.push([[x + frac(bl, br), y], [x + 1, y + frac(br, tr)]]);\n          break;\n        case 14:\n          segments.push([[x, y + frac(bl, tl)], [x + frac(bl, br), y]]);\n          break;\n        case 15:\n          continue;\n      }\n    }\n  }\n  return segments;\n  function frac(z0, z1) {\n    if (z0 === z1) {\n      return 0.5;\n    }\n    let t = (threshold - z0) / (z1 - z0);\n    return t > 1 ? 1 : t < 0 ? 0 : t;\n  }\n}\nfunction assembleRings(segments, matrix) {\n  const dy = matrix.length;\n  const dx = matrix[0].length;\n  const contours = [];\n  const result = [];\n  while (segments.length > 0) {\n    const contour = [...segments.shift()];\n    contours.push(contour);\n    let found;\n    do {\n      found = false;\n      for (let i = 0; i < segments.length; i++) {\n        const segment = segments[i];\n        if (segment[0][0] === contour[contour.length - 1][0] && segment[0][1] === contour[contour.length - 1][1]) {\n          found = true;\n          contour.push(segment[1]);\n          segments.splice(i, 1);\n          break;\n        }\n        if (segment[1][0] === contour[0][0] && segment[1][1] === contour[0][1]) {\n          found = true;\n          contour.unshift(segment[0]);\n          segments.splice(i, 1);\n          break;\n        }\n      }\n    } while (found);\n  }\n  while (contours.length > 0) {\n    const contour = contours[0];\n    if (contour[0][0] === contour[contour.length - 1][0] && contour[0][1] === contour[contour.length - 1][1]) {\n      result.push(contour);\n      contours.shift();\n      continue;\n    }\n    const end = contour[contour.length - 1];\n    let match;\n    let corner;\n    if (end[0] === 0 && end[1] !== 0) {\n      match = getAdjacentContour(contours, contour2 => contour2[0][0] === 0 && contour2[0][1] < end[1],\n      // left side, below end\n      (a, b) => b[0][1] - a[0][1]\n      // prefer positions to the top\n      );\n      corner = [0, 0];\n    } else if (end[1] === 0 && end[0] !== dx - 1) {\n      match = getAdjacentContour(contours, contour2 => contour2[0][1] === 0 && contour2[0][0] > end[0],\n      // bottom side, right of end\n      (a, b) => a[0][0] - b[0][0]\n      // prefer positions to the left\n      );\n      corner = [dx - 1, 0];\n    } else if (end[0] === dx - 1 && end[1] !== dy - 1) {\n      match = getAdjacentContour(contours, contour2 => contour2[0][0] === dx - 1 && contour2[0][1] > end[1],\n      // right side, above end\n      (a, b) => a[0][1] - b[0][1]\n      // prefer positions to the bottom\n      );\n      corner = [dx - 1, dy - 1];\n    } else if (end[1] === dy - 1 && end[0] !== 0) {\n      match = getAdjacentContour(contours, contour2 => contour2[0][1] === dy - 1 && contour2[0][0] < end[0],\n      // top side, left of end\n      (a, b) => b[0][0] - a[0][0]\n      // prefer positions to the right\n      );\n      corner = [0, dy - 1];\n    } else {\n      throw new Error(\"Contour not closed but is not along an edge\");\n    }\n    if (match === -1) {\n      contour.push(corner);\n    } else if (match === 0) {\n      contour.push([contour[0][0], contour[0][1]]);\n      result.push(contour);\n      contours.shift();\n    } else {\n      const matchedContour = contours[match];\n      contours.splice(match, 1);\n      for (const p of matchedContour) {\n        contour.push(p);\n      }\n    }\n  }\n  for (let i = 0; i < result.length; i++) {\n    if (result[i].length < 4) {\n      result.splice(i, 1);\n      i--;\n    }\n  }\n  return result;\n}\nfunction rescaleContours(contours, matrix, points) {\n  const gridBbox = bbox(points);\n  const originalWidth = gridBbox[2] - gridBbox[0];\n  const originalHeigth = gridBbox[3] - gridBbox[1];\n  const x0 = gridBbox[0];\n  const y0 = gridBbox[1];\n  const matrixWidth = matrix[0].length - 1;\n  const matrixHeight = matrix.length - 1;\n  const scaleX = originalWidth / matrixWidth;\n  const scaleY = originalHeigth / matrixHeight;\n  return contours.map(function (contour) {\n    contour.groupedRings = contour.groupedRings.map(function (lineRingSet) {\n      return lineRingSet.map(function (lineRing) {\n        return lineRing.map(point => [point[0] * scaleX + x0, point[1] * scaleY + y0]);\n      });\n    });\n    return contour;\n  });\n}\nfunction orderByArea(ringsCoords) {\n  const ringsWithArea = ringsCoords.map(function (coords) {\n    return {\n      ring: coords,\n      area: area(polygon([coords]))\n    };\n  });\n  ringsWithArea.sort(function (a, b) {\n    return b.area - a.area;\n  });\n  return ringsWithArea.map(function (x) {\n    return x.ring;\n  });\n}\nfunction groupNestedRings(orderedLinearRings) {\n  const lrList = orderedLinearRings.map(lr => {\n    return {\n      lrCoordinates: lr,\n      grouped: false\n    };\n  });\n  const groupedLinearRingsCoords = [];\n  while (!allGrouped(lrList)) {\n    for (let i = 0; i < lrList.length; i++) {\n      if (!lrList[i].grouped) {\n        const group = [];\n        group.push(lrList[i].lrCoordinates);\n        lrList[i].grouped = true;\n        const outerMostPoly = polygon([lrList[i].lrCoordinates]);\n        OUTER: for (let j = i + 1; j < lrList.length; j++) {\n          if (!lrList[j].grouped) {\n            const lrPoly = polygon([lrList[j].lrCoordinates]);\n            if (isInside(lrPoly, outerMostPoly)) {\n              for (let k = 1; k < group.length; k++) {\n                if (isInside(lrPoly, polygon([group[k]]))) {\n                  continue OUTER;\n                }\n              }\n              group.push(lrList[j].lrCoordinates);\n              lrList[j].grouped = true;\n            }\n          }\n        }\n        groupedLinearRingsCoords.push(group);\n      }\n    }\n  }\n  return groupedLinearRingsCoords;\n}\nfunction isInside(testPolygon, targetPolygon) {\n  const points = explode(testPolygon);\n  for (let i = 0; i < points.features.length; i++) {\n    if (!booleanPointInPolygon(points.features[i], targetPolygon)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction allGrouped(list) {\n  for (let i = 0; i < list.length; i++) {\n    if (list[i].grouped === false) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getAdjacentContour(contours, test, sort) {\n  let match = -1;\n  for (let j = 0; j < contours.length; j++) {\n    if (test(contours[j])) {\n      if (match === -1 || sort(contours[match], contours[j]) > 0) {\n        match = j;\n      }\n    }\n  }\n  return match;\n}\nvar index_default = isobands;\nexport { index_default as default, isobands };","map":{"version":3,"names":["bbox","area","booleanPointInPolygon","explode","collectionOf","collectionOf2","polygon","multiPolygon","featureCollection","isObject","isObject2","getCoords","featureEach","gridToMatrix","grid","options","Error","zProperty","flip","flags","pointsMatrix","sortPointsByLatLng","matrix","r","length","pointRow","row","c","point","properties","push","matrixPosition","points","pointsByLatitude","lat","orderedRowsByLatitude","Object","keys","map","rowOrderedByLongitude","sort","a","b","pointMatrix","isobands","pointGrid","breaks","commonProperties","breaksProperties","Array","isArray","dx","i","contours","createContourLines","rescaleContours","multipolygons","contour","index","contourProperties","__spreadValues","multiP","groupedRings","property","prevSegments","getSegments","upperBand","lowerBand","segments","reverseSegments","segment","pos","reverse","rings","assembleRings","concat","orderedRings","orderByArea","polygons","groupNestedRings","dy","threshold","y","x","tr","br","bl","tl","frac","avg","above","z0","z1","t","result","shift","found","splice","unshift","end","match","corner","getAdjacentContour","contour2","matchedContour","p","gridBbox","originalWidth","originalHeigth","x0","y0","matrixWidth","matrixHeight","scaleX","scaleY","lineRingSet","lineRing","ringsCoords","ringsWithArea","coords","ring","orderedLinearRings","lrList","lr","lrCoordinates","grouped","groupedLinearRingsCoords","allGrouped","group","outerMostPoly","OUTER","j","lrPoly","isInside","k","testPolygon","targetPolygon","features","list","test","index_default"],"sources":["C:\\Users\\HP\\map-drawing-app\\-Shapes-Drawer\\node_modules\\@turf\\isobands\\index.ts","C:\\Users\\HP\\map-drawing-app\\-Shapes-Drawer\\node_modules\\@turf\\isobands\\lib\\grid-to-matrix.js"],"sourcesContent":["import { bbox } from \"@turf/bbox\";\nimport { area } from \"@turf/area\";\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { explode } from \"@turf/explode\";\nimport { collectionOf } from \"@turf/invariant\";\nimport {\n  polygon,\n  multiPolygon,\n  featureCollection,\n  isObject,\n} from \"@turf/helpers\";\n\nimport {\n  FeatureCollection,\n  Point,\n  GeoJsonProperties,\n  MultiPolygon,\n  Position,\n  Polygon,\n  Feature,\n} from \"geojson\";\nimport { gridToMatrix } from \"./lib/grid-to-matrix.js\";\n\ntype GroupRingProps = { [prop: string]: string };\ntype GroupedRings =\n  | {\n      groupedRings: Position[][][];\n    }\n  | GroupRingProps;\n\n/**\n * Takes a square or rectangular grid {@link FeatureCollection} of {@link Point} features with z-values and an array of\n * value breaks and generates filled contour isobands.\n *\n * @function\n * @param {FeatureCollection<Point>} pointGrid input points - must be square or rectangular and already gridded. That is, to have consistent x and y dimensions and be at least 2x2 in size.\n * @param {Array<number>} breaks where to draw contours\n * @param {Object} [options={}] options on output\n * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled\n * @param {Object} [options.commonProperties={}] GeoJSON properties passed to ALL isobands\n * @param {Array<Object>} [options.breaksProperties=[]] GeoJSON properties passed, in order, to the correspondent isoband (order defined by breaks)\n * @returns {FeatureCollection<MultiPolygon>} a FeatureCollection of {@link MultiPolygon} features representing isobands\n */\nfunction isobands(\n  pointGrid: FeatureCollection<Point>,\n  breaks: number[],\n  options?: {\n    zProperty?: string;\n    commonProperties?: GeoJsonProperties;\n    breaksProperties?: GeoJsonProperties[];\n  }\n): FeatureCollection<MultiPolygon> {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  const zProperty = options.zProperty || \"elevation\";\n  const commonProperties = options.commonProperties || {};\n  const breaksProperties = options.breaksProperties || [];\n\n  // Validation\n  collectionOf(pointGrid, \"Point\", \"Input must contain Points\");\n  if (!breaks) throw new Error(\"breaks is required\");\n  if (!Array.isArray(breaks)) throw new Error(\"breaks is not an Array\");\n  if (!isObject(commonProperties))\n    throw new Error(\"commonProperties is not an Object\");\n  if (!Array.isArray(breaksProperties))\n    throw new Error(\"breaksProperties is not an Array\");\n\n  // Isoband methods\n  const matrix = gridToMatrix(pointGrid, { zProperty: zProperty, flip: true });\n\n  // A quick note on what 'top' and 'bottom' mean in coordinate system of `matrix`:\n  // Remember that the southern hemisphere is represented by negative numbers,\n  // so a matrix Y of 0 is actually the *bottom*, and a Y of dy - 1 is the *top*.\n\n  // check that the resulting matrix has consistent x and y dimensions and\n  // has at least a 2x2 size so that we can actually build grid squares\n  const dx = matrix[0].length;\n  if (matrix.length < 2 || dx < 2) {\n    throw new Error(\"Matrix of points must be at least 2x2\");\n  }\n  for (let i = 1; i < matrix.length; i++) {\n    if (matrix[i].length !== dx) {\n      throw new Error(\"Matrix of points is not uniform in the x dimension\");\n    }\n  }\n\n  let contours = createContourLines(matrix, breaks, zProperty);\n  contours = rescaleContours(contours, matrix, pointGrid);\n\n  const multipolygons = contours.map((contour, index) => {\n    if (breaksProperties[index] && !isObject(breaksProperties[index])) {\n      throw new Error(\"Each mappedProperty is required to be an Object\");\n    }\n    // collect all properties\n    const contourProperties = {\n      ...commonProperties,\n      ...breaksProperties[index],\n    };\n\n    contourProperties[zProperty] = (contour as GroupRingProps)[zProperty];\n\n    const multiP = multiPolygon(\n      contour.groupedRings as Position[][][],\n      contourProperties\n    );\n    return multiP;\n  });\n\n  return featureCollection(multipolygons);\n}\n\n/**\n * Creates the contours lines (featuresCollection of polygon features) from the 2D data grid\n *\n * Marchingsquares process the grid data as a 3D representation of a function on a 2D plane, therefore it\n * assumes the points (x-y coordinates) are one 'unit' distance. The result of the IsoBands function needs to be\n * rescaled, with turfjs, to the original area and proportions on the map\n *\n * @private\n * @param {Array<Array<number>>} matrix Grid Data\n * @param {Array<number>} breaks Breaks\n * @param {string} [property='elevation'] Property\n * @returns {Array<any>} contours\n */\nfunction createContourLines(\n  matrix: number[][],\n  breaks: number[],\n  property: string\n): GroupedRings[] {\n  const contours: GroupedRings[] = [];\n\n  let prevSegments: Position[][];\n  for (let i = 1; i < breaks.length; i++) {\n    // the first time through this loop, we need to create the segments for the first break\n    if (i === 1) {\n      prevSegments = getSegments(matrix, +breaks[0]);\n    }\n\n    const upperBand = +breaks[i]; // make sure the breaks value is a number\n    const lowerBand = +breaks[i - 1];\n    const segments = getSegments(matrix, upperBand);\n\n    // We will use breaks[i]'s rings to help close breaks[i-1]'s rings.\n    // breaks[i]'s rings are clockwise from the point of view of breaks[i - 1] and must be reversed for proper counterclockwise ordering.\n    // At the same time, we clone each Position, so that we don't use the same Position Array instance in different output geometries.\n    const reverseSegments = segments.map((segment) =>\n      // note that we (in-place) reverse the array result of .map and not the original segment itself.\n      segment.map((pos) => [pos[0], pos[1]]).reverse()\n    );\n\n    // use the segments from breaks[i-1] and breaks[i] to create rings, which will\n    // then be combined into polygons in the next steps.\n    const rings = assembleRings(prevSegments!.concat(reverseSegments), matrix);\n\n    // as per GeoJson rules for creating a Polygon, make sure the first element\n    // in the array of LinearRings represents the exterior ring (i.e. biggest area),\n    // and any subsequent elements represent interior rings (i.e. smaller area);\n    // this avoids rendering issues of the MultiPolygons on the map\n    const orderedRings = orderByArea(rings);\n    const polygons = groupNestedRings(orderedRings);\n\n    // If we got no polygons, we can infer that the values are either all above, below, or between the thresholds.\n    // If everything is between, we need a polygon that covers the entire grid\n    // see https://github.com/Turfjs/turf/issues/1797, https://github.com/Turfjs/turf/issues/2956\n    if (\n      polygons.length === 0 &&\n      matrix[0][0] < upperBand &&\n      matrix[0][0] >= lowerBand\n    ) {\n      const dx = matrix[0].length;\n      const dy = matrix.length;\n      polygons.push([\n        [\n          [0, 0],\n          [dx - 1, 0],\n          [dx - 1, dy - 1],\n          [0, dy - 1],\n          [0, 0],\n        ],\n      ]);\n    }\n\n    // this can add an entry where groupedRings is exactly an empty array\n    contours.push({\n      groupedRings: polygons,\n      [property]: lowerBand + \"-\" + upperBand,\n    });\n\n    prevSegments = segments;\n  }\n\n  return contours;\n}\n\n/**\n * Run marching squares across the matrix and calculate the implied counterclockwise ordered line segments from each cell.\n * @see https://en.wikipedia.org/wiki/Marching_squares for an visualization of the different cases\n * @private\n */\nfunction getSegments(\n  matrix: ReadonlyArray<ReadonlyArray<number>>,\n  threshold: number\n): [Position, Position][] {\n  const segments: [Position, Position][] = [];\n\n  const dx = matrix[0].length;\n  const dy = matrix.length;\n\n  for (let y = 0; y < dy - 1; y++) {\n    for (let x = 0; x < dx - 1; x++) {\n      const tr = matrix[y + 1][x + 1];\n      const br = matrix[y][x + 1];\n      const bl = matrix[y][x];\n      const tl = matrix[y + 1][x];\n\n      let grid =\n        (tl >= threshold ? 8 : 0) |\n        (tr >= threshold ? 4 : 0) |\n        (br >= threshold ? 2 : 0) |\n        (bl >= threshold ? 1 : 0);\n\n      switch (grid) {\n        case 0:\n          continue;\n        case 1:\n          segments.push([\n            [x + frac(bl, br), y],\n            [x, y + frac(bl, tl)],\n          ]);\n          break;\n        case 2:\n          segments.push([\n            [x + 1, y + frac(br, tr)],\n            [x + frac(bl, br), y],\n          ]);\n          break;\n        case 3:\n          segments.push([\n            [x + 1, y + frac(br, tr)],\n            [x, y + frac(bl, tl)],\n          ]);\n          break;\n        case 4:\n          segments.push([\n            [x + frac(tl, tr), y + 1],\n            [x + 1, y + frac(br, tr)],\n          ]);\n          break;\n        case 5: {\n          // use the average of the 4 corners to differentiate the saddle case and correctly honor the counter-clockwise winding\n          const avg = (tl + tr + br + bl) / 4;\n          const above = avg >= threshold;\n\n          if (above) {\n            segments.push(\n              [\n                [x + frac(tl, tr), y + 1],\n                [x, y + frac(bl, tl)],\n              ],\n              [\n                [x + frac(bl, br), y],\n                [x + 1, y + frac(br, tr)],\n              ]\n            );\n          } else {\n            segments.push(\n              [\n                [x + frac(tl, tr), y + 1],\n                [x + 1, y + frac(br, tr)],\n              ],\n              [\n                [x + frac(bl, br), y],\n                [x, y + frac(bl, tl)],\n              ]\n            );\n          }\n          break;\n        }\n        case 6:\n          segments.push([\n            [x + frac(tl, tr), y + 1],\n            [x + frac(bl, br), y],\n          ]);\n          break;\n        case 7:\n          segments.push([\n            [x + frac(tl, tr), y + 1],\n            [x, y + frac(bl, tl)],\n          ]);\n          break;\n        case 8:\n          segments.push([\n            [x, y + frac(bl, tl)],\n            [x + frac(tl, tr), y + 1],\n          ]);\n          break;\n        case 9:\n          segments.push([\n            [x + frac(bl, br), y],\n            [x + frac(tl, tr), y + 1],\n          ]);\n          break;\n        case 10: {\n          const avg = (tl + tr + br + bl) / 4;\n          const above = avg >= threshold;\n\n          if (above) {\n            segments.push(\n              [\n                [x, y + frac(bl, tl)],\n                [x + frac(bl, br), y],\n              ],\n              [\n                [x + 1, y + frac(br, tr)],\n                [x + frac(tl, tr), y + 1],\n              ]\n            );\n          } else {\n            segments.push(\n              [\n                [x, y + frac(bl, tl)],\n                [x + frac(tl, tr), y + 1],\n              ],\n              [\n                [x + 1, y + frac(br, tr)],\n                [x + frac(bl, br), y],\n              ]\n            );\n          }\n          break;\n        }\n        case 11:\n          segments.push([\n            [x + 1, y + frac(br, tr)],\n            [x + frac(tl, tr), y + 1],\n          ]);\n          break;\n        case 12:\n          segments.push([\n            [x, y + frac(bl, tl)],\n            [x + 1, y + frac(br, tr)],\n          ]);\n          break;\n        case 13:\n          segments.push([\n            [x + frac(bl, br), y],\n            [x + 1, y + frac(br, tr)],\n          ]);\n          break;\n        case 14:\n          segments.push([\n            [x, y + frac(bl, tl)],\n            [x + frac(bl, br), y],\n          ]);\n          break;\n        case 15:\n          // all above\n          continue;\n      }\n    }\n  }\n\n  return segments;\n\n  // get the linear interpolation fraction of how far z is between z0 and z1\n  // See https://github.com/fschutt/marching-squares/blob/master/src/lib.rs\n  function frac(z0: number, z1: number): number {\n    if (z0 === z1) {\n      return 0.5;\n    }\n\n    let t = (threshold - z0) / (z1 - z0);\n    return t > 1 ? 1 : t < 0 ? 0 : t;\n  }\n}\n\n/**\n * Create a list of closed rings from the combined segments from breaks[i] and breaks[i-1].\n * @private\n */\nfunction assembleRings(\n  segments: Position[][],\n  matrix: number[][]\n): Position[][] {\n  const dy = matrix.length;\n  const dx = matrix[0].length;\n\n  const contours: Position[][] = [];\n  const result: Position[][] = [];\n\n  // Assemble contiguous line segments into contours. These are at least LineStrings,\n  // but for features that do not touch the edge of the matrix, they will actually wind up\n  // being an entirely closed LinearRing.\n  while (segments.length > 0) {\n    const contour: Position[] = [...segments.shift()!];\n    contours.push(contour);\n\n    let found: boolean;\n    do {\n      found = false;\n      for (let i = 0; i < segments.length; i++) {\n        const segment = segments[i];\n        // add the segment's end point to the end of the contour\n        if (\n          segment[0][0] === contour[contour.length - 1][0] &&\n          segment[0][1] === contour[contour.length - 1][1]\n        ) {\n          found = true;\n          contour.push(segment[1]);\n          segments.splice(i, 1);\n          break;\n        }\n        // add the segment's start point to the start of the contour\n        if (\n          segment[1][0] === contour[0][0] &&\n          segment[1][1] === contour[0][1]\n        ) {\n          found = true;\n          contour.unshift(segment[0]);\n          segments.splice(i, 1);\n          break;\n        }\n\n        // note that because the segments are all guaranteed to be counterclockwise,\n        // we do not join segment start to end of the contour or segment end to the start of contour\n      }\n\n      // if we reach here with found === false, that means that no remaining segments can be\n      // added to our contour. We begin again creating the next indepdenent contour.\n    } while (found);\n  }\n\n  // Now we loop again, taking the contours and ensuring that all of them are closed rings.\n  // Using segments from two different breaks[], and enforcing closed polygons are the\n  // two the major difference between the implementation of @turf/isolines and @turf/isobands.\n  while (contours.length > 0) {\n    const contour = contours[0];\n\n    // if a contour is closed, store it in the results and move to the next contour\n    if (\n      contour[0][0] === contour[contour.length - 1][0] &&\n      contour[0][1] === contour[contour.length - 1][1]\n    ) {\n      result.push(contour);\n      contours.shift();\n      continue;\n    }\n\n    // A contour that is not already closed is guaranteed to touch the bounding box of the matrix.\n    // We know that the polygon is ordered counter-clockwise, so we just need to follow\n    // the bounding box in a counterclockwise direction, looking for a contour to append.\n    // We may need to insert new positions along the corners, but we will eventually close the ring.\n\n    const end = contour[contour.length - 1];\n\n    let match: number;\n    let corner: Position;\n    if (end[0] === 0 && end[1] !== 0) {\n      // left side\n      match = getAdjacentContour(\n        contours,\n        (contour) => contour[0][0] === 0 && contour[0][1] < end[1], // left side, below end\n        (a, b) => b[0][1] - a[0][1] // prefer positions to the top\n      );\n      corner = [0, 0]; // bottom left corner\n    } else if (end[1] === 0 && end[0] !== dx - 1) {\n      // bottom side\n      match = getAdjacentContour(\n        contours,\n        (contour) => contour[0][1] === 0 && contour[0][0] > end[0], // bottom side, right of end\n        (a, b) => a[0][0] - b[0][0] // prefer positions to the left\n      );\n      corner = [dx - 1, 0]; // bottom right corner\n    } else if (end[0] === dx - 1 && end[1] !== dy - 1) {\n      // right side\n      match = getAdjacentContour(\n        contours,\n        (contour) => contour[0][0] === dx - 1 && contour[0][1] > end[1], // right side, above end\n        (a, b) => a[0][1] - b[0][1] // prefer positions to the bottom\n      );\n      corner = [dx - 1, dy - 1]; // top right corner\n    } else if (end[1] === dy - 1 && end[0] !== 0) {\n      // top side\n      match = getAdjacentContour(\n        contours,\n        (contour) => contour[0][1] === dy - 1 && contour[0][0] < end[0], // top side, left of end\n        (a, b) => b[0][0] - a[0][0] // prefer positions to the right\n      );\n      corner = [0, dy - 1]; // top left corner\n    } else {\n      throw new Error(\"Contour not closed but is not along an edge\");\n    }\n\n    if (match === -1) {\n      // we did not match a contour on this side, so we add a point in the corner to\n      // continue creating our linestring in counterclockwise order. The next\n      // run of the loop will continue trying to assemble the current contour on the next side.\n      contour.push(corner);\n    } else if (match === 0) {\n      // We looped back to a contour, and it was ourself. That means that we finished closing the ring.\n      // Add the contour to the result and remove it from the contours list to start working\n      // on the next contour.\n      contour.push([contour[0][0], contour[0][1]]);\n      result.push(contour);\n      contours.shift();\n    } else {\n      // We matched a contour, but it is not the one we're currently closing.\n      // That means that we get to add its points to our own, and remove that contour entirely.\n      // On the next loop, we'll continue trying to close the same contour, but this time from\n      // the final Position in contour will be the end of contours[match].\n      const matchedContour = contours[match];\n      contours.splice(match, 1);\n      for (const p of matchedContour) {\n        contour.push(p);\n      }\n    }\n  }\n\n  // If we get *just* a corner we close it immediately with itself, which results in\n  // a 2 point 'ring', which has zero area. We omit these before returning.\n  for (let i = 0; i < result.length; i++) {\n    if (result[i].length < 4) {\n      result.splice(i, 1);\n      i--;\n    }\n  }\n\n  return result;\n}\n\n/**\n * Transform isobands of 2D grid to polygons for the map\n *\n * @private\n * @param {Array<any>} contours Contours\n * @param {Array<Array<number>>} matrix Grid Data\n * @param {Object} points Points by Latitude\n * @returns {Array<any>} contours\n */\nfunction rescaleContours(\n  contours: GroupedRings[],\n  matrix: number[][],\n  points: FeatureCollection<Point>\n): GroupedRings[] {\n  // get dimensions (on the map) of the original grid\n  const gridBbox = bbox(points); // [ minX, minY, maxX, maxY ]\n  const originalWidth = gridBbox[2] - gridBbox[0];\n  const originalHeigth = gridBbox[3] - gridBbox[1];\n\n  // get origin, which is the first point of the last row on the rectangular data on the map\n  const x0 = gridBbox[0];\n  const y0 = gridBbox[1];\n  // get number of cells per side\n  const matrixWidth = matrix[0].length - 1;\n  const matrixHeight = matrix.length - 1;\n  // calculate the scaling factor between matrix and rectangular grid on the map\n  const scaleX = originalWidth / matrixWidth;\n  const scaleY = originalHeigth / matrixHeight;\n\n  // resize and shift each point/line of the isobands\n  return contours.map(function (contour) {\n    contour.groupedRings = (contour.groupedRings as Position[][][]).map(\n      function (lineRingSet) {\n        return lineRingSet.map(function (lineRing) {\n          return lineRing.map((point: Position) => [\n            point[0] * scaleX + x0,\n            point[1] * scaleY + y0,\n          ]);\n        });\n      }\n    );\n\n    return contour;\n  });\n}\n\n/*  utility functions */\n\n/**\n * Returns an array of coordinates (of LinearRings) in descending order by area\n *\n * @private\n * @param {Array<LineString>} ringsCoords array of closed LineString\n * @returns {Array} array of the input LineString ordered by area\n */\nfunction orderByArea(ringsCoords: Position[][]): Position[][] {\n  const ringsWithArea = ringsCoords.map(function (coords) {\n    // associate each lineRing with its area\n    return { ring: coords, area: area(polygon([coords])) };\n  });\n  ringsWithArea.sort(function (a, b) {\n    // bigger --> smaller\n    return b.area - a.area;\n  });\n  // create a new array of linearRings coordinates ordered by their area\n  return ringsWithArea.map(function (x) {\n    return x.ring;\n  });\n}\n\n/**\n * Returns an array of arrays of coordinates, each representing\n * a set of (coordinates of) nested LinearRings,\n * i.e. the first ring contains all the others\n *\n * @private\n * @param {Array} orderedLinearRings array of coordinates (of LinearRings) in descending order by area\n * @returns {Array<Array>} Array of coordinates of nested LinearRings\n */\nfunction groupNestedRings(orderedLinearRings: Position[][]): Position[][][] {\n  // create a list of the (coordinates of) LinearRings\n  const lrList = orderedLinearRings.map((lr) => {\n    return { lrCoordinates: lr, grouped: false };\n  });\n  const groupedLinearRingsCoords: Position[][][] = [];\n\n  while (!allGrouped(lrList)) {\n    for (let i = 0; i < lrList.length; i++) {\n      if (!lrList[i].grouped) {\n        // create new group starting with the larger not already grouped ring\n        const group: Position[][] = [];\n        group.push(lrList[i].lrCoordinates);\n        lrList[i].grouped = true;\n        const outerMostPoly = polygon([lrList[i].lrCoordinates]);\n        // group all the rings contained by the outermost ring\n        OUTER: for (let j = i + 1; j < lrList.length; j++) {\n          if (!lrList[j].grouped) {\n            const lrPoly = polygon([lrList[j].lrCoordinates]);\n            if (isInside(lrPoly, outerMostPoly)) {\n              // we cannot group any linear rings that are contained in hole rings for this group\n              for (let k = 1; k < group.length; k++) {\n                if (isInside(lrPoly, polygon([group[k]]))) {\n                  continue OUTER;\n                }\n              }\n              group.push(lrList[j].lrCoordinates);\n              lrList[j].grouped = true;\n            }\n          }\n        }\n        // insert the new group\n        groupedLinearRingsCoords.push(group);\n      }\n    }\n  }\n  return groupedLinearRingsCoords;\n}\n\n/**\n * @private\n * @param {Polygon} testPolygon polygon of interest\n * @param {Polygon} targetPolygon polygon you want to compare with\n * @returns {boolean} true if test-Polygon is inside target-Polygon\n */\nfunction isInside(\n  testPolygon: Feature<Polygon>,\n  targetPolygon: Feature<Polygon>\n): boolean {\n  const points = explode(testPolygon);\n  for (let i = 0; i < points.features.length; i++) {\n    if (!booleanPointInPolygon(points.features[i], targetPolygon)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @private\n * @param {Array<Object>} list list of objects which might contain the 'group' attribute\n * @returns {boolean} true if all the objects in the list are marked as grouped\n */\nfunction allGrouped(\n  list: { grouped: boolean; lrCoordinates: Position[] }[]\n): boolean {\n  for (let i = 0; i < list.length; i++) {\n    if (list[i].grouped === false) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Utility function to help close contours into rings\n *\n * @private\n * @param contours The list of contours\n * @param test Return true if a contour is a candidate for being joined\n * @param sort Compare two candidates, returning a positive number will swap the best match from a to b\n * @returns An index of the contour to join, or -1 if no contour was found\n */\nfunction getAdjacentContour(\n  contours: Position[][],\n  test: (contour: Position[]) => boolean,\n  sort: (a: Position[], b: Position[]) => number\n): number {\n  let match = -1;\n  for (let j = 0; j < contours.length; j++) {\n    if (test(contours[j])) {\n      if (match === -1 || sort(contours[match], contours[j]) > 0) {\n        match = j;\n      }\n    }\n  }\n\n  return match;\n}\n\nexport { isobands };\nexport default isobands;\n","import { getCoords, collectionOf } from \"@turf/invariant\";\nimport { featureEach } from \"@turf/meta\";\nimport { isObject } from \"@turf/helpers\";\n\n/**\n * Takes a {@link Point} grid and returns a correspondent matrix {Array<Array<number>>}\n * of the 'property' values\n *\n * @name gridToMatrix\n * @param {FeatureCollection<Point>} grid of points\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled\n * @param {boolean} [options.flip=false] returns the matrix upside-down\n * @param {boolean} [options.flags=false] flags, adding a `matrixPosition` array field ([row, column]) to its properties,\n * the grid points with coordinates on the matrix\n * @returns {Array<Array<number>>} matrix of property values\n * @example\n *   var extent = [-70.823364, -33.553984, -70.473175, -33.302986];\n *   var cellSize = 3;\n *   var grid = turf.pointGrid(extent, cellSize);\n *   // add a random property to each point between 0 and 60\n *   for (var i = 0; i < grid.features.length; i++) {\n *     grid.features[i].properties.elevation = (Math.random() * 60);\n *   }\n *   gridToMatrix(grid);\n *   //= [\n *     [ 1, 13, 10,  9, 10, 13, 18],\n *     [34,  8,  5,  4,  5,  8, 13],\n *     [10,  5,  2,  1,  2,  5,  4],\n *     [ 0,  4, 56, 19,  1,  4,  9],\n *     [10,  5,  2,  1,  2,  5, 10],\n *     [57,  8,  5,  4,  5,  0, 57],\n *     [ 3, 13, 10,  9,  5, 13, 18],\n *     [18, 13, 10,  9, 78, 13, 18]\n *   ]\n */\nfunction gridToMatrix(grid, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var zProperty = options.zProperty || \"elevation\";\n  var flip = options.flip;\n  var flags = options.flags;\n\n  // validation\n  collectionOf(grid, \"Point\", \"input must contain Points\");\n\n  var pointsMatrix = sortPointsByLatLng(grid, flip);\n\n  var matrix = [];\n  // create property matrix from sorted points\n  // looping order matters here\n  for (var r = 0; r < pointsMatrix.length; r++) {\n    var pointRow = pointsMatrix[r];\n    var row = [];\n    for (var c = 0; c < pointRow.length; c++) {\n      var point = pointRow[c];\n      // Check if zProperty exist\n      if (point.properties[zProperty]) row.push(point.properties[zProperty]);\n      else row.push(0);\n      // add flags\n      if (flags === true) point.properties.matrixPosition = [r, c];\n    }\n    matrix.push(row);\n  }\n\n  return matrix;\n}\n\n/**\n * Sorts points by latitude and longitude, creating a 2-dimensional array of points\n *\n * @private\n * @param {FeatureCollection<Point>} points GeoJSON Point features\n * @param {boolean} [flip=false] returns the matrix upside-down\n * @returns {Array<Array<Point>>} points ordered by latitude and longitude\n */\nfunction sortPointsByLatLng(points, flip) {\n  var pointsByLatitude = {};\n\n  // divide points by rows with the same latitude\n  featureEach(points, function (point) {\n    var lat = getCoords(point)[1];\n    if (!pointsByLatitude[lat]) pointsByLatitude[lat] = [];\n    pointsByLatitude[lat].push(point);\n  });\n\n  // sort points (with the same latitude) by longitude\n  var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function (lat) {\n    var row = pointsByLatitude[lat];\n    var rowOrderedByLongitude = row.sort(function (a, b) {\n      return getCoords(a)[0] - getCoords(b)[0];\n    });\n    return rowOrderedByLongitude;\n  });\n\n  // sort rows (of points with the same latitude) by latitude\n  var pointMatrix = orderedRowsByLatitude.sort(function (a, b) {\n    if (flip) return getCoords(a[0])[1] - getCoords(b[0])[1];\n    else return getCoords(b[0])[1] - getCoords(a[0])[1];\n  });\n\n  return pointMatrix;\n}\n\nexport { gridToMatrix };\nexport default gridToMatrix;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}