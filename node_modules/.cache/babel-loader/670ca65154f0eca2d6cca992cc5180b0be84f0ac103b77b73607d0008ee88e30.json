{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n// index.ts\nimport { distance } from \"@turf/distance\";\nimport { flattenEach } from \"@turf/meta\";\nimport { point, degreesToRadians, radiansToDegrees } from \"@turf/helpers\";\nimport { getCoord, getCoords } from \"@turf/invariant\";\nfunction nearestPointOnLine(lines, pt) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!lines || !pt) {\n    throw new Error(\"lines and pt are required arguments\");\n  }\n  const ptPos = getCoord(pt);\n  let closestPt = point([Infinity, Infinity], {\n    dist: Infinity,\n    index: -1,\n    multiFeatureIndex: -1,\n    location: -1\n  });\n  let length = 0;\n  flattenEach(lines, function (line, _featureIndex, multiFeatureIndex) {\n    const coords = getCoords(line);\n    for (let i = 0; i < coords.length - 1; i++) {\n      const start = point(coords[i]);\n      const startPos = getCoord(start);\n      const stop = point(coords[i + 1]);\n      const stopPos = getCoord(stop);\n      const sectionLength = distance(start, stop, options);\n      let intersectPos;\n      let wasEnd;\n      if (stopPos[0] === ptPos[0] && stopPos[1] === ptPos[1]) {\n        [intersectPos, wasEnd] = [stopPos, true];\n      } else if (startPos[0] === ptPos[0] && startPos[1] === ptPos[1]) {\n        [intersectPos, wasEnd] = [startPos, false];\n      } else {\n        [intersectPos, wasEnd] = nearestPointOnSegment(startPos, stopPos, ptPos);\n      }\n      const intersectPt = point(intersectPos, {\n        dist: distance(pt, intersectPos, options),\n        multiFeatureIndex,\n        location: length + distance(start, intersectPos, options)\n      });\n      if (intersectPt.properties.dist < closestPt.properties.dist) {\n        closestPt = __spreadProps(__spreadValues({}, intersectPt), {\n          properties: __spreadProps(__spreadValues({}, intersectPt.properties), {\n            // Legacy behaviour where index progresses to next segment # if we\n            // went with the end point this iteration.\n            index: wasEnd ? i + 1 : i\n          })\n        });\n      }\n      length += sectionLength;\n    }\n  });\n  return closestPt;\n}\nfunction dot(v1, v2) {\n  const [v1x, v1y, v1z] = v1;\n  const [v2x, v2y, v2z] = v2;\n  return v1x * v2x + v1y * v2y + v1z * v2z;\n}\nfunction cross(v1, v2) {\n  const [v1x, v1y, v1z] = v1;\n  const [v2x, v2y, v2z] = v2;\n  return [v1y * v2z - v1z * v2y, v1z * v2x - v1x * v2z, v1x * v2y - v1y * v2x];\n}\nfunction magnitude(v) {\n  return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2) + Math.pow(v[2], 2));\n}\nfunction normalize(v) {\n  const mag = magnitude(v);\n  return [v[0] / mag, v[1] / mag, v[2] / mag];\n}\nfunction lngLatToVector(a) {\n  const lat = degreesToRadians(a[1]);\n  const lng = degreesToRadians(a[0]);\n  return [Math.cos(lat) * Math.cos(lng), Math.cos(lat) * Math.sin(lng), Math.sin(lat)];\n}\nfunction vectorToLngLat(v) {\n  const [x, y, z] = v;\n  const zClamp = Math.min(Math.max(z, -1), 1);\n  const lat = radiansToDegrees(Math.asin(zClamp));\n  const lng = radiansToDegrees(Math.atan2(y, x));\n  return [lng, lat];\n}\nfunction nearestPointOnSegment(posA, posB, posC) {\n  const A = lngLatToVector(posA);\n  const B = lngLatToVector(posB);\n  const C = lngLatToVector(posC);\n  const segmentAxis = cross(A, B);\n  if (segmentAxis[0] === 0 && segmentAxis[1] === 0 && segmentAxis[2] === 0) {\n    if (dot(A, B) > 0) {\n      return [[...posB], true];\n    } else {\n      return [[...posC], false];\n    }\n  }\n  const targetAxis = cross(segmentAxis, C);\n  if (targetAxis[0] === 0 && targetAxis[1] === 0 && targetAxis[2] === 0) {\n    return [[...posB], true];\n  }\n  const intersectionAxis = cross(targetAxis, segmentAxis);\n  const I1 = normalize(intersectionAxis);\n  const I2 = [-I1[0], -I1[1], -I1[2]];\n  const I = dot(C, I1) > dot(C, I2) ? I1 : I2;\n  const segmentAxisNorm = normalize(segmentAxis);\n  const cmpAI = dot(cross(A, I), segmentAxisNorm);\n  const cmpIB = dot(cross(I, B), segmentAxisNorm);\n  if (cmpAI >= 0 && cmpIB >= 0) {\n    return [vectorToLngLat(I), false];\n  }\n  if (dot(A, C) > dot(B, C)) {\n    return [[...posA], false];\n  } else {\n    return [[...posB], true];\n  }\n}\nvar index_default = nearestPointOnLine;\nexport { index_default as default, nearestPointOnLine };","map":{"version":3,"names":["distance","flattenEach","point","degreesToRadians","radiansToDegrees","getCoord","getCoords","nearestPointOnLine","lines","pt","options","arguments","length","undefined","Error","ptPos","closestPt","Infinity","dist","index","multiFeatureIndex","location","line","_featureIndex","coords","i","start","startPos","stop","stopPos","sectionLength","intersectPos","wasEnd","nearestPointOnSegment","intersectPt","properties","__spreadProps","__spreadValues","dot","v1","v2","v1x","v1y","v1z","v2x","v2y","v2z","cross","magnitude","v","Math","sqrt","pow","normalize","mag","lngLatToVector","a","lat","lng","cos","sin","vectorToLngLat","x","y","z","zClamp","min","max","asin","atan2","posA","posB","posC","A","B","C","segmentAxis","targetAxis","intersectionAxis","I1","I2","I","segmentAxisNorm","cmpAI","cmpIB","index_default"],"sources":["C:\\Users\\HP\\map-drawing-app\\node_modules\\@turf\\nearest-point-on-line\\index.ts"],"sourcesContent":["import { Feature, Point, Position, LineString, MultiLineString } from \"geojson\";\nimport { distance } from \"@turf/distance\";\nimport { flattenEach } from \"@turf/meta\";\nimport {\n  point,\n  degreesToRadians,\n  radiansToDegrees,\n  Coord,\n  Units,\n} from \"@turf/helpers\";\nimport { getCoord, getCoords } from \"@turf/invariant\";\n\n/**\n * Returns the nearest point on a line to a given point.\n *\n * If any of the segments in the input line string are antipodal and therefore\n * have an undefined arc, this function will instead return that the point lies\n * on the line.\n *\n * @function\n * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to\n * @param {Geometry|Feature<Point>|number[]} pt point to snap from\n * @param {Object} [options={}] Optional parameters\n * @param {Units} [options.units='kilometers'] Supports all valid Turf {@link https://turfjs.org/docs/api/types/Units Units}\n * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain four values: `index`: closest point was found on nth line part, `multiFeatureIndex`: closest point was found on the nth line of the `MultiLineString`, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.\n * @example\n * var line = turf.lineString([\n *     [-77.031669, 38.878605],\n *     [-77.029609, 38.881946],\n *     [-77.020339, 38.884084],\n *     [-77.025661, 38.885821],\n *     [-77.021884, 38.889563],\n *     [-77.019824, 38.892368]\n * ]);\n * var pt = turf.point([-77.037076, 38.884017]);\n *\n * var snapped = turf.nearestPointOnLine(line, pt, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line, pt, snapped];\n * snapped.properties['marker-color'] = '#00f';\n */\nfunction nearestPointOnLine<G extends LineString | MultiLineString>(\n  lines: Feature<G> | G,\n  pt: Coord,\n  options: { units?: Units } = {}\n): Feature<\n  Point,\n  {\n    dist: number;\n    index: number;\n    multiFeatureIndex: number;\n    location: number;\n    [key: string]: any;\n  }\n> {\n  if (!lines || !pt) {\n    throw new Error(\"lines and pt are required arguments\");\n  }\n\n  const ptPos = getCoord(pt);\n\n  let closestPt: Feature<\n    Point,\n    { dist: number; index: number; multiFeatureIndex: number; location: number }\n  > = point([Infinity, Infinity], {\n    dist: Infinity,\n    index: -1,\n    multiFeatureIndex: -1,\n    location: -1,\n  });\n\n  let length = 0.0;\n  flattenEach(\n    lines,\n    function (line: any, _featureIndex: number, multiFeatureIndex: number) {\n      const coords: any = getCoords(line);\n\n      for (let i = 0; i < coords.length - 1; i++) {\n        //start - start of current line section\n        const start: Feature<Point, { dist: number }> = point(coords[i]);\n        const startPos = getCoord(start);\n\n        //stop - end of current line section\n        const stop: Feature<Point, { dist: number }> = point(coords[i + 1]);\n        const stopPos = getCoord(stop);\n\n        // sectionLength\n        const sectionLength = distance(start, stop, options);\n        let intersectPos: Position;\n        let wasEnd: boolean;\n\n        // Short circuit if snap point is start or end position of the line\n        // Test the end position first for consistency in case they are\n        // coincident\n        if (stopPos[0] === ptPos[0] && stopPos[1] === ptPos[1]) {\n          [intersectPos, wasEnd] = [stopPos, true];\n        } else if (startPos[0] === ptPos[0] && startPos[1] === ptPos[1]) {\n          [intersectPos, wasEnd] = [startPos, false];\n        } else {\n          // Otherwise, find the nearest point the hard way.\n          [intersectPos, wasEnd] = nearestPointOnSegment(\n            startPos,\n            stopPos,\n            ptPos\n          );\n        }\n\n        const intersectPt = point(intersectPos, {\n          dist: distance(pt, intersectPos, options),\n          multiFeatureIndex: multiFeatureIndex,\n          location: length + distance(start, intersectPos, options),\n        });\n\n        if (intersectPt.properties.dist < closestPt.properties.dist) {\n          closestPt = {\n            ...intersectPt,\n            properties: {\n              ...intersectPt.properties,\n              // Legacy behaviour where index progresses to next segment # if we\n              // went with the end point this iteration.\n              index: wasEnd ? i + 1 : i,\n            },\n          };\n        }\n\n        // update length\n        length += sectionLength;\n      }\n    }\n  );\n\n  return closestPt;\n}\n\n// A simple Vector3 type for cartesian operations.\ntype Vector = [number, number, number];\n\nfunction dot(v1: Vector, v2: Vector): number {\n  const [v1x, v1y, v1z] = v1;\n  const [v2x, v2y, v2z] = v2;\n  return v1x * v2x + v1y * v2y + v1z * v2z;\n}\n\n// https://en.wikipedia.org/wiki/Cross_product\nfunction cross(v1: Vector, v2: Vector): Vector {\n  const [v1x, v1y, v1z] = v1;\n  const [v2x, v2y, v2z] = v2;\n  return [v1y * v2z - v1z * v2y, v1z * v2x - v1x * v2z, v1x * v2y - v1y * v2x];\n}\n\nfunction magnitude(v: Vector): number {\n  return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2) + Math.pow(v[2], 2));\n}\n\nfunction normalize(v: Vector): Vector {\n  const mag = magnitude(v);\n  return [v[0] / mag, v[1] / mag, v[2] / mag];\n}\n\nfunction lngLatToVector(a: Position): Vector {\n  const lat = degreesToRadians(a[1]);\n  const lng = degreesToRadians(a[0]);\n  return [\n    Math.cos(lat) * Math.cos(lng),\n    Math.cos(lat) * Math.sin(lng),\n    Math.sin(lat),\n  ];\n}\n\nfunction vectorToLngLat(v: Vector): Position {\n  const [x, y, z] = v;\n  // Clamp the z-value to ensure that is inside the [-1, 1] domain as required\n  // by asin. Note therefore that this function should only be applied to unit\n  // vectors so z > 1 should not exist\n  const zClamp = Math.min(Math.max(z, -1), 1);\n  const lat = radiansToDegrees(Math.asin(zClamp));\n  const lng = radiansToDegrees(Math.atan2(y, x));\n\n  return [lng, lat];\n}\n\nfunction nearestPointOnSegment(\n  posA: Position, // start point of segment to measure to\n  posB: Position, // end point of segment to measure to\n  posC: Position // point to measure from\n): [Position, boolean] {\n  // Based heavily on this article on finding cross track distance to an arc:\n  // https://gis.stackexchange.com/questions/209540/projecting-cross-track-distance-on-great-circle\n\n  // Convert spherical (lng, lat) to cartesian vector coords (x, y, z)\n  // In the below https://tikz.net/spherical_1/ we convert lng (ðœ™) and lat (ðœƒ)\n  // into vectors with x, y, and z components with a length (r) of 1.\n  const A = lngLatToVector(posA); // the vector from 0,0,0 to posA\n  const B = lngLatToVector(posB); // ... to posB\n  const C = lngLatToVector(posC); // ... to posC\n\n  // The axis (normal vector) of the great circle plane containing the line segment\n  const segmentAxis = cross(A, B);\n\n  // Two degenerate cases exist for the segment axis cross product. The first is\n  // when vectors are aligned (within the bounds of floating point tolerance).\n  // The second is where vectors are antipodal (again within the bounds of\n  // tolerance. Both cases produce a [0, 0, 0] cross product which invalidates\n  // the rest of the algorithm, but each case must be handled separately:\n  // - The aligned case indicates coincidence of A and B. therefore this can be\n  //   an early return assuming the closest point is the end (for consistency).\n  // - The antipodal case is truly degenerate - an infinte number of great\n  //   circles are possible and one will always pass through C. However, given\n  //   that this case is both highly unlikely to occur in practice and that is\n  //   will usually be logically sound to return that the point is on the\n  //   segment, we choose to return the provided point.\n  if (segmentAxis[0] === 0 && segmentAxis[1] === 0 && segmentAxis[2] === 0) {\n    if (dot(A, B) > 0) {\n      return [[...posB], true];\n    } else {\n      return [[...posC], false];\n    }\n  }\n\n  // The axis of the great circle passing through the segment's axis and the\n  // target point\n  const targetAxis = cross(segmentAxis, C);\n\n  // This cross product also has a degenerate case where the segment axis is\n  // coincident with or antipodal to the target point. In this case the point\n  // is equidistant to the entire segment. For consistency, we early return the\n  // endpoint as the matching point.\n  if (targetAxis[0] === 0 && targetAxis[1] === 0 && targetAxis[2] === 0) {\n    return [[...posB], true];\n  }\n\n  // The line of intersection between the two great circle planes\n  const intersectionAxis = cross(targetAxis, segmentAxis);\n\n  // Vectors to the two points these great circles intersect are the normalized\n  // intersection and its antipodes\n  const I1 = normalize(intersectionAxis);\n  const I2: Vector = [-I1[0], -I1[1], -I1[2]];\n\n  // Figure out which is the closest intersection to this segment of the great circle\n  // Note that for points on a unit sphere, the dot product represents the\n  // cosine of the angle between the two vectors which monotonically increases\n  // the closer the two points are together and therefore determines proximity\n  const I = dot(C, I1) > dot(C, I2) ? I1 : I2;\n\n  // I is the closest intersection to the segment, though might not actually be\n  // ON the segment. To test whether the closest intersection lies on the arc or\n  // not, we do a cross product comparison to check rotation around the unit\n  // circle defined by the great circle plane.\n  const segmentAxisNorm = normalize(segmentAxis);\n  const cmpAI = dot(cross(A, I), segmentAxisNorm);\n  const cmpIB = dot(cross(I, B), segmentAxisNorm);\n\n  // When both comparisons are positive, the rotation from A to I to B is in the\n  // same direction, implying that I lies between A and B\n  if (cmpAI >= 0 && cmpIB >= 0) {\n    return [vectorToLngLat(I), false];\n  }\n\n  // Finally process the case where the intersection is not on the segment,\n  // using the dot product with the original point to find the closest endpoint\n  if (dot(A, C) > dot(B, C)) {\n    // Clone position when returning as it is reasonable to not expect structural\n    // sharing on the returned Position in all return cases\n    return [[...posA], false];\n  } else {\n    return [[...posB], true];\n  }\n}\n\nexport { nearestPointOnLine };\nexport default nearestPointOnLine;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}