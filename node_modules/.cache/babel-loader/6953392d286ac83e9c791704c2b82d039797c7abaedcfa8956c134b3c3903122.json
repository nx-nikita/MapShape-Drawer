{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\n// index.ts\nimport { getType } from \"@turf/invariant\";\nimport { featureEach, geomEach } from \"@turf/meta\";\nimport { pointToLineDistance } from \"@turf/point-to-line-distance\";\nfunction nearestPointToLine(points, line) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const units = options.units;\n  const properties = options.properties || {};\n  const pts = normalize(points);\n  if (!pts.features.length) {\n    throw new Error(\"points must contain features\");\n  }\n  if (!line) {\n    throw new Error(\"line is required\");\n  }\n  if (getType(line) !== \"LineString\") {\n    throw new Error(\"line must be a LineString\");\n  }\n  let dist = Infinity;\n  let pt = null;\n  featureEach(pts, point => {\n    const d = pointToLineDistance(point, line, {\n      units\n    });\n    if (d < dist) {\n      dist = d;\n      pt = point;\n    }\n  });\n  if (pt) {\n    pt.properties = __spreadValues(__spreadValues(__spreadValues({}, {\n      dist\n    }), pt.properties), properties);\n  }\n  return pt;\n}\nfunction normalize(points) {\n  const features = [];\n  const type = points.geometry ? points.geometry.type : points.type;\n  switch (type) {\n    case \"GeometryCollection\":\n      geomEach(points, geom => {\n        if (geom.type === \"Point\") {\n          features.push({\n            type: \"Feature\",\n            properties: {},\n            geometry: geom\n          });\n        }\n      });\n      return {\n        type: \"FeatureCollection\",\n        features\n      };\n    case \"FeatureCollection\":\n      points.features = points.features.filter(feature => {\n        return feature.geometry.type === \"Point\";\n      });\n      return points;\n    default:\n      throw new Error(\"points must be a Point Collection\");\n  }\n}\nvar index_default = nearestPointToLine;\nexport { index_default as default, nearestPointToLine };","map":{"version":3,"names":["getType","featureEach","geomEach","pointToLineDistance","nearestPointToLine","points","line","options","arguments","length","undefined","units","properties","pts","normalize","features","Error","dist","Infinity","pt","point","d","__spreadValues","type","geometry","geom","push","filter","feature","index_default"],"sources":["C:\\Users\\HP\\map-drawing-app\\node_modules\\@turf\\nearest-point-to-line\\index.ts"],"sourcesContent":["import {\n  Feature,\n  FeatureCollection,\n  GeometryCollection,\n  LineString,\n  Point,\n  GeoJsonProperties,\n} from \"geojson\";\nimport { Units } from \"@turf/helpers\";\nimport { getType } from \"@turf/invariant\";\nimport { featureEach, geomEach } from \"@turf/meta\";\nimport { pointToLineDistance } from \"@turf/point-to-line-distance\";\n\n/**\n * Returns the closest {@link Point|point}, of a {@link FeatureCollection|collection} of points,\n * to a {@link LineString|line}. The returned point has a `dist` property indicating its distance to the line.\n *\n * @function\n * @param {FeatureCollection|GeometryCollection<Point>} points Point Collection\n * @param {Feature|Geometry<LineString>} line Line Feature\n * @param {Object} [options] Optional parameters\n * @param {Units} [options.units='kilometers'] unit of the output distance property. Supports all valid Turf {@link https://turfjs.org/docs/api/types/Units Units}.\n * (eg: degrees, radians, miles, or kilometers)\n * @param {Object} [options.properties={}] Translate Properties to Point\n * @returns {Feature<Point>} the closest point\n * @example\n * var pt1 = turf.point([0, 0]);\n * var pt2 = turf.point([0.5, 0.5]);\n * var points = turf.featureCollection([pt1, pt2]);\n * var line = turf.lineString([[1,1], [-1,1]]);\n *\n * var nearest = turf.nearestPointToLine(points, line);\n *\n * //addToMap\n * var addToMap = [nearest, line];\n */\nfunction nearestPointToLine<P = { dist: number; [key: string]: any }>(\n  points:\n    | FeatureCollection<Point>\n    | Feature<GeometryCollection>\n    | GeometryCollection,\n  line: Feature<LineString> | LineString,\n  options: {\n    units?: Units;\n    properties?: GeoJsonProperties;\n  } = {}\n): Feature<Point, P> {\n  const units = options.units;\n  const properties = options.properties || {};\n\n  // validation\n  const pts = normalize(points);\n  if (!pts.features.length) {\n    throw new Error(\"points must contain features\");\n  }\n\n  if (!line) {\n    throw new Error(\"line is required\");\n  }\n  if (getType(line) !== \"LineString\") {\n    throw new Error(\"line must be a LineString\");\n  }\n\n  let dist = Infinity;\n  let pt: any = null;\n\n  featureEach(pts, (point) => {\n    const d = pointToLineDistance(point, line, { units });\n    if (d < dist) {\n      dist = d;\n      pt = point;\n    }\n  });\n  /*\n   * Translate Properties to final Point, priorities:\n   * 1. options.properties\n   * 2. inherent Point properties\n   * 3. dist custom properties created by NearestPointToLine\n   */\n  if (pt) {\n    pt.properties = { ...{ dist }, ...pt.properties, ...properties };\n  }\n  return pt;\n}\n\n/**\n * Convert Collection to FeatureCollection\n *\n * @private\n * @param {FeatureCollection|GeometryCollection} points Points\n * @returns {FeatureCollection<Point>} points\n */\nfunction normalize(points: any): FeatureCollection<Point> {\n  const features: any[] = [];\n  const type = points.geometry ? points.geometry.type : points.type;\n  switch (type) {\n    case \"GeometryCollection\":\n      geomEach(points, (geom) => {\n        if (geom.type === \"Point\") {\n          features.push({ type: \"Feature\", properties: {}, geometry: geom });\n        }\n      });\n      return { type: \"FeatureCollection\", features };\n    case \"FeatureCollection\":\n      points.features = points.features.filter((feature: any) => {\n        return feature.geometry.type === \"Point\";\n      });\n      return points;\n    default:\n      throw new Error(\"points must be a Point Collection\");\n  }\n}\n\nexport { nearestPointToLine };\nexport default nearestPointToLine;\n"],"mappings":";;;;;;;;;;;;;;;;;;;AASA,SAASA,OAAA,QAAe;AACxB,SAASC,WAAA,EAAaC,QAAA,QAAgB;AACtC,SAASC,mBAAA,QAA2B;AAyBpC,SAASC,mBACPC,MAAA,EAIAC,IAAA,EAKmB;EAAA,IAJnBC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAGI,CAAC;EAEL,MAAMG,KAAA,GAAQJ,OAAA,CAAQI,KAAA;EACtB,MAAMC,UAAA,GAAaL,OAAA,CAAQK,UAAA,IAAc,CAAC;EAG1C,MAAMC,GAAA,GAAMC,SAAA,CAAUT,MAAM;EAC5B,IAAI,CAACQ,GAAA,CAAIE,QAAA,CAASN,MAAA,EAAQ;IACxB,MAAM,IAAIO,KAAA,CAAM,8BAA8B;EAChD;EAEA,IAAI,CAACV,IAAA,EAAM;IACT,MAAM,IAAIU,KAAA,CAAM,kBAAkB;EACpC;EACA,IAAIhB,OAAA,CAAQM,IAAI,MAAM,cAAc;IAClC,MAAM,IAAIU,KAAA,CAAM,2BAA2B;EAC7C;EAEA,IAAIC,IAAA,GAAOC,QAAA;EACX,IAAIC,EAAA,GAAU;EAEdlB,WAAA,CAAYY,GAAA,EAAMO,KAAA,IAAU;IAC1B,MAAMC,CAAA,GAAIlB,mBAAA,CAAoBiB,KAAA,EAAOd,IAAA,EAAM;MAAEK;IAAM,CAAC;IACpD,IAAIU,CAAA,GAAIJ,IAAA,EAAM;MACZA,IAAA,GAAOI,CAAA;MACPF,EAAA,GAAKC,KAAA;IACP;EACF,CAAC;EAOD,IAAID,EAAA,EAAI;IACNA,EAAA,CAAGP,UAAA,GAAaU,cAAA,CAAAA,cAAA,CAAAA,cAAA,KAAK;MAAEL;IAAK,IAAME,EAAA,CAAGP,UAAA,GAAeA,UAAA;EACtD;EACA,OAAOO,EAAA;AACT;AASA,SAASL,UAAUT,MAAA,EAAuC;EACxD,MAAMU,QAAA,GAAkB,EAAC;EACzB,MAAMQ,IAAA,GAAOlB,MAAA,CAAOmB,QAAA,GAAWnB,MAAA,CAAOmB,QAAA,CAASD,IAAA,GAAOlB,MAAA,CAAOkB,IAAA;EAC7D,QAAQA,IAAA;IACN,KAAK;MACHrB,QAAA,CAASG,MAAA,EAASoB,IAAA,IAAS;QACzB,IAAIA,IAAA,CAAKF,IAAA,KAAS,SAAS;UACzBR,QAAA,CAASW,IAAA,CAAK;YAAEH,IAAA,EAAM;YAAWX,UAAA,EAAY,CAAC;YAAGY,QAAA,EAAUC;UAAK,CAAC;QACnE;MACF,CAAC;MACD,OAAO;QAAEF,IAAA,EAAM;QAAqBR;MAAS;IAC/C,KAAK;MACHV,MAAA,CAAOU,QAAA,GAAWV,MAAA,CAAOU,QAAA,CAASY,MAAA,CAAQC,OAAA,IAAiB;QACzD,OAAOA,OAAA,CAAQJ,QAAA,CAASD,IAAA,KAAS;MACnC,CAAC;MACD,OAAOlB,MAAA;IACT;MACE,MAAM,IAAIW,KAAA,CAAM,mCAAmC;EACvD;AACF;AAGA,IAAOa,aAAA,GAAQzB,kBAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}