{"ast":null,"code":"// index.ts\nimport { polygon, isObject, isNumber, point, radiansToDegrees } from \"@turf/helpers\";\nimport { destination } from \"@turf/destination\";\nimport { transformRotate } from \"@turf/transform-rotate\";\nimport { getCoord } from \"@turf/invariant\";\nfunction ellipse(center, xSemiAxis, ySemiAxis, options) {\n  options = options || {};\n  let steps = options.steps || 64;\n  const units = options.units || \"kilometers\";\n  let angle = options.angle || 0;\n  const pivot = options.pivot || center;\n  const properties = options.properties || {};\n  if (!center) throw new Error(\"center is required\");\n  if (!xSemiAxis) throw new Error(\"xSemiAxis is required\");\n  if (!ySemiAxis) throw new Error(\"ySemiAxis is required\");\n  if (!isObject(options)) throw new Error(\"options must be an object\");\n  if (!isNumber(steps)) throw new Error(\"steps must be a number\");\n  if (!isNumber(angle)) throw new Error(\"angle must be a number\");\n  const centerCoords = getCoord(transformRotate(point(getCoord(center)), angle, {\n    pivot\n  }));\n  angle = -90 + angle;\n  steps = Math.ceil(steps / 4);\n  let quadrantParameters = [];\n  let parameters = [];\n  const a = xSemiAxis;\n  const b = ySemiAxis;\n  const c = b;\n  const m = (a - b) / (Math.PI / 2);\n  const A = (a + b) * Math.PI / 4;\n  const v = 0.5;\n  const k = steps;\n  let w = 0;\n  let x = 0;\n  for (let i = 0; i < steps; i++) {\n    x += w;\n    if (m === 0) {\n      w = A / k / c;\n    } else {\n      w = (-(m * x + c) + Math.sqrt(Math.pow(m * x + c, 2) - 4 * (v * m) * -(A / k))) / (2 * (v * m));\n    }\n    if (x != 0) {\n      quadrantParameters.push(x);\n    }\n  }\n  parameters.push(0);\n  for (let i = 0; i < quadrantParameters.length; i++) {\n    parameters.push(quadrantParameters[i]);\n  }\n  parameters.push(Math.PI / 2);\n  for (let i = 0; i < quadrantParameters.length; i++) {\n    parameters.push(Math.PI - quadrantParameters[quadrantParameters.length - i - 1]);\n  }\n  parameters.push(Math.PI);\n  for (let i = 0; i < quadrantParameters.length; i++) {\n    parameters.push(Math.PI + quadrantParameters[i]);\n  }\n  parameters.push(3 * Math.PI / 2);\n  for (let i = 0; i < quadrantParameters.length; i++) {\n    parameters.push(2 * Math.PI - quadrantParameters[quadrantParameters.length - i - 1]);\n  }\n  parameters.push(0);\n  const coords = [];\n  for (const param of parameters) {\n    const theta = Math.atan2(b * Math.sin(param), a * Math.cos(param));\n    const r = Math.sqrt(Math.pow(a, 2) * Math.pow(b, 2) / (Math.pow(a * Math.sin(theta), 2) + Math.pow(b * Math.cos(theta), 2)));\n    coords.push(destination(centerCoords, r, angle + radiansToDegrees(theta), {\n      units\n    }).geometry.coordinates);\n  }\n  return polygon([coords], properties);\n}\nvar index_default = ellipse;\nexport { index_default as default, ellipse };","map":{"version":3,"names":["polygon","isObject","isNumber","point","radiansToDegrees","destination","transformRotate","getCoord","ellipse","center","xSemiAxis","ySemiAxis","options","steps","units","angle","pivot","properties","Error","centerCoords","Math","ceil","quadrantParameters","parameters","a","b","c","m","PI","A","v","k","w","x","i","sqrt","pow","push","length","coords","param","theta","atan2","sin","cos","r","geometry","coordinates","index_default"],"sources":["C:\\Users\\HP\\map-drawing-app\\node_modules\\@turf\\ellipse\\index.ts"],"sourcesContent":["import {\n  polygon,\n  isObject,\n  isNumber,\n  Coord,\n  Units,\n  point,\n  radiansToDegrees,\n} from \"@turf/helpers\";\nimport { destination } from \"@turf/destination\";\nimport { transformRotate } from \"@turf/transform-rotate\";\nimport { getCoord } from \"@turf/invariant\";\nimport { GeoJsonProperties, Feature, Polygon, Position } from \"geojson\";\n\n/**\n * Takes a {@link Point} and calculates the ellipse polygon given two semi-axes expressed in variable units and steps for precision.\n *\n * @param {Coord} center center point\n * @param {number} xSemiAxis semi (major) axis of the ellipse along the x-axis\n * @param {number} ySemiAxis semi (minor) axis of the ellipse along the y-axis\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.angle=0] angle of rotation in decimal degrees, positive clockwise\n * @param {Coord} [options.pivot=center] point around which any rotation will be performed\n * @param {number} [options.steps=64] number of steps\n * @param {Units} [options.units='kilometers'] unit of measurement for axes. Supports all valid Turf {@link https://turfjs.org/docs/api/types/Units Units}\n * @param {Object} [options.properties={}] properties\n * @returns {Feature<Polygon>} ellipse polygon\n * @example\n * var center = [-75, 40];\n * var xSemiAxis = 5;\n * var ySemiAxis = 2;\n * var ellipse = turf.ellipse(center, xSemiAxis, ySemiAxis);\n *\n * //addToMap\n * var addToMap = [turf.point(center), ellipse]\n */\nfunction ellipse(\n  center: Coord,\n  xSemiAxis: number,\n  ySemiAxis: number,\n  options: {\n    steps?: number;\n    units?: Units;\n    angle?: number;\n    pivot?: Coord;\n    properties?: GeoJsonProperties;\n  }\n): Feature<Polygon> {\n  // Optional params\n  options = options || {};\n  let steps = options.steps || 64;\n  const units = options.units || \"kilometers\";\n  let angle = options.angle || 0;\n  const pivot = options.pivot || center;\n  const properties = options.properties || {};\n  // validation\n  if (!center) throw new Error(\"center is required\");\n  if (!xSemiAxis) throw new Error(\"xSemiAxis is required\");\n  if (!ySemiAxis) throw new Error(\"ySemiAxis is required\");\n  if (!isObject(options)) throw new Error(\"options must be an object\");\n  if (!isNumber(steps)) throw new Error(\"steps must be a number\");\n  if (!isNumber(angle)) throw new Error(\"angle must be a number\");\n\n  const centerCoords = getCoord(\n    transformRotate(point(getCoord(center)), angle, { pivot })\n  );\n\n  angle = -90 + angle;\n\n  // Divide steps by 4 for one quadrant\n  steps = Math.ceil(steps / 4);\n\n  let quadrantParameters = [];\n  let parameters = [];\n\n  const a = xSemiAxis;\n  const b = ySemiAxis;\n\n  // Gradient x intersect\n  const c = b;\n\n  // Gradient of line\n  const m = (a - b) / (Math.PI / 2);\n\n  // Area under line\n  const A = ((a + b) * Math.PI) / 4;\n\n  // Weighting function\n  const v = 0.5;\n\n  const k = steps;\n\n  let w = 0;\n  let x = 0;\n\n  for (let i = 0; i < steps; i++) {\n    x += w;\n\n    if (m === 0) {\n      // It's a circle, so use simplified c*w - A/k == 0\n      w = A / k / c;\n    } else {\n      // Otherwise, use full (v*m)*w^2 + (m*x+c)*w - A/k == 0\n      // Solve as quadratic ax^2 + bx + c = 0\n      w =\n        (-(m * x + c) +\n          Math.sqrt(Math.pow(m * x + c, 2) - 4 * (v * m) * -(A / k))) /\n        (2 * (v * m));\n    }\n    if (x != 0) {\n      // easier to add it later to avoid having twice the same point\n      quadrantParameters.push(x);\n    }\n  }\n\n  //NE\n  parameters.push(0);\n  for (let i = 0; i < quadrantParameters.length; i++) {\n    parameters.push(quadrantParameters[i]);\n  }\n  //NW\n  parameters.push(Math.PI / 2);\n  for (let i = 0; i < quadrantParameters.length; i++) {\n    parameters.push(\n      Math.PI - quadrantParameters[quadrantParameters.length - i - 1]\n    );\n  }\n  //SW\n  parameters.push(Math.PI);\n  for (let i = 0; i < quadrantParameters.length; i++) {\n    parameters.push(Math.PI + quadrantParameters[i]);\n  }\n  //SE\n  parameters.push((3 * Math.PI) / 2);\n  for (let i = 0; i < quadrantParameters.length; i++) {\n    parameters.push(\n      2 * Math.PI - quadrantParameters[quadrantParameters.length - i - 1]\n    );\n  }\n  parameters.push(0);\n\n  // We can now construct the ellipse\n  const coords: Position[] = [];\n  for (const param of parameters) {\n    const theta = Math.atan2(b * Math.sin(param), a * Math.cos(param));\n    const r = Math.sqrt(\n      (Math.pow(a, 2) * Math.pow(b, 2)) /\n        (Math.pow(a * Math.sin(theta), 2) + Math.pow(b * Math.cos(theta), 2))\n    );\n    coords.push(\n      destination(centerCoords, r, angle + radiansToDegrees(theta), {\n        units: units,\n      }).geometry.coordinates\n    );\n  }\n  return polygon([coords], properties);\n}\n\nexport { ellipse };\nexport default ellipse;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}