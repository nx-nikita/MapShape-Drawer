{"ast":null,"code":"// index.ts\nimport { featureCollection, lineString, multiLineString } from \"@turf/helpers\";\nimport { getGeom } from \"@turf/invariant\";\nfunction polygonToLine(poly) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const geom = getGeom(poly);\n  if (!options.properties && poly.type === \"Feature\") {\n    options.properties = poly.properties;\n  }\n  switch (geom.type) {\n    case \"Polygon\":\n      return singlePolygonToLine(geom, options);\n    case \"MultiPolygon\":\n      return multiPolygonToLine(geom, options);\n    default:\n      throw new Error(\"invalid poly\");\n  }\n}\nfunction singlePolygonToLine(poly) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const geom = getGeom(poly);\n  const coords = geom.coordinates;\n  const properties = options.properties ? options.properties : poly.type === \"Feature\" ? poly.properties : {};\n  return coordsToLine(coords, properties);\n}\nfunction multiPolygonToLine(multiPoly) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const geom = getGeom(multiPoly);\n  const coords = geom.coordinates;\n  const properties = options.properties ? options.properties : multiPoly.type === \"Feature\" ? multiPoly.properties : {};\n  const lines = [];\n  coords.forEach(coord => {\n    lines.push(coordsToLine(coord, properties));\n  });\n  return featureCollection(lines);\n}\nfunction coordsToLine(coords, properties) {\n  if (coords.length > 1) {\n    return multiLineString(coords, properties);\n  }\n  return lineString(coords[0], properties);\n}\nvar index_default = polygonToLine;\nexport { coordsToLine, index_default as default, multiPolygonToLine, polygonToLine, singlePolygonToLine };","map":{"version":3,"names":["featureCollection","lineString","multiLineString","getGeom","polygonToLine","poly","options","arguments","length","undefined","geom","properties","type","singlePolygonToLine","multiPolygonToLine","Error","coords","coordinates","coordsToLine","multiPoly","lines","forEach","coord","push","index_default"],"sources":["C:\\Users\\HP\\map-drawing-app\\node_modules\\@turf\\polygon-to-line\\index.ts"],"sourcesContent":["import { featureCollection, lineString, multiLineString } from \"@turf/helpers\";\nimport {\n  Feature,\n  FeatureCollection,\n  LineString,\n  MultiLineString,\n  MultiPolygon,\n  Polygon,\n  GeoJsonProperties,\n} from \"geojson\";\nimport { getGeom } from \"@turf/invariant\";\n\n/**\n * Converts a {@link Polygon} to {@link LineString|(Multi)LineString} or {@link MultiPolygon} to a\n * {@link FeatureCollection} of {@link LineString|(Multi)LineString}.\n *\n * @function\n * @param {Feature<Polygon|MultiPolygon>} poly Feature to convert\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] translates GeoJSON properties to Feature\n * @returns {FeatureCollection|Feature<LineString|MultiLinestring>} converted (Multi)Polygon to (Multi)LineString\n * @example\n * var poly = turf.polygon([[[125, -30], [145, -30], [145, -20], [125, -20], [125, -30]]]);\n *\n * var line = turf.polygonToLine(poly);\n *\n * //addToMap\n * var addToMap = [line];\n */\nfunction polygonToLine<\n  G extends Polygon | MultiPolygon,\n  P extends GeoJsonProperties = GeoJsonProperties,\n>(\n  poly: Feature<G, P> | G,\n  options: { properties?: any } = {}\n):\n  | Feature<LineString | MultiLineString, P>\n  | FeatureCollection<LineString | MultiLineString, P> {\n  const geom: any = getGeom(poly);\n  if (!options.properties && poly.type === \"Feature\") {\n    options.properties = poly.properties;\n  }\n  switch (geom.type) {\n    case \"Polygon\":\n      return singlePolygonToLine(geom, options);\n    case \"MultiPolygon\":\n      return multiPolygonToLine(geom, options);\n    default:\n      throw new Error(\"invalid poly\");\n  }\n}\n\n/**\n * @private\n */\nfunction singlePolygonToLine<\n  G extends Polygon,\n  P extends GeoJsonProperties = GeoJsonProperties,\n>(\n  poly: Feature<G, P> | G,\n  options: { properties?: any } = {}\n): Feature<LineString | MultiLineString, P> {\n  const geom = getGeom(poly);\n  const coords: any[] = geom.coordinates;\n  const properties: any = options.properties\n    ? options.properties\n    : poly.type === \"Feature\"\n      ? poly.properties\n      : {};\n\n  return coordsToLine(coords, properties);\n}\n\n/**\n * @private\n */\nfunction multiPolygonToLine<\n  G extends MultiPolygon,\n  P extends GeoJsonProperties = GeoJsonProperties,\n>(\n  multiPoly: Feature<G, P> | G,\n  options: { properties?: P } = {}\n): FeatureCollection<LineString | MultiLineString, P> {\n  const geom = getGeom(multiPoly);\n  const coords: any[] = geom.coordinates;\n  const properties: any = options.properties\n    ? options.properties\n    : multiPoly.type === \"Feature\"\n      ? multiPoly.properties\n      : {};\n\n  const lines: Array<Feature<LineString | MultiLineString, P>> = [];\n  coords.forEach((coord) => {\n    lines.push(coordsToLine(coord, properties));\n  });\n  return featureCollection(lines);\n}\n\n/**\n * @private\n */\nfunction coordsToLine<P extends GeoJsonProperties = GeoJsonProperties>(\n  coords: number[][][],\n  properties: P\n): Feature<LineString | MultiLineString, P> {\n  if (coords.length > 1) {\n    return multiLineString(coords, properties);\n  }\n  return lineString(coords[0], properties);\n}\n\nexport { polygonToLine, coordsToLine, multiPolygonToLine, singlePolygonToLine };\nexport default polygonToLine;\n"],"mappings":";AAAA,SAASA,iBAAA,EAAmBC,UAAA,EAAYC,eAAA,QAAuB;AAU/D,SAASC,OAAA,QAAe;AAmBxB,SAASC,cAIPC,IAAA,EAIqD;EAAA,IAHrDC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAgC,CAAC;EAIjC,MAAMG,IAAA,GAAYP,OAAA,CAAQE,IAAI;EAC9B,IAAI,CAACC,OAAA,CAAQK,UAAA,IAAcN,IAAA,CAAKO,IAAA,KAAS,WAAW;IAClDN,OAAA,CAAQK,UAAA,GAAaN,IAAA,CAAKM,UAAA;EAC5B;EACA,QAAQD,IAAA,CAAKE,IAAA;IACX,KAAK;MACH,OAAOC,mBAAA,CAAoBH,IAAA,EAAMJ,OAAO;IAC1C,KAAK;MACH,OAAOQ,kBAAA,CAAmBJ,IAAA,EAAMJ,OAAO;IACzC;MACE,MAAM,IAAIS,KAAA,CAAM,cAAc;EAClC;AACF;AAKA,SAASF,oBAIPR,IAAA,EAE0C;EAAA,IAD1CC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAgC,CAAC;EAEjC,MAAMG,IAAA,GAAOP,OAAA,CAAQE,IAAI;EACzB,MAAMW,MAAA,GAAgBN,IAAA,CAAKO,WAAA;EAC3B,MAAMN,UAAA,GAAkBL,OAAA,CAAQK,UAAA,GAC5BL,OAAA,CAAQK,UAAA,GACRN,IAAA,CAAKO,IAAA,KAAS,YACZP,IAAA,CAAKM,UAAA,GACL,CAAC;EAEP,OAAOO,YAAA,CAAaF,MAAA,EAAQL,UAAU;AACxC;AAKA,SAASG,mBAIPK,SAAA,EAEoD;EAAA,IADpDb,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA8B,CAAC;EAE/B,MAAMG,IAAA,GAAOP,OAAA,CAAQgB,SAAS;EAC9B,MAAMH,MAAA,GAAgBN,IAAA,CAAKO,WAAA;EAC3B,MAAMN,UAAA,GAAkBL,OAAA,CAAQK,UAAA,GAC5BL,OAAA,CAAQK,UAAA,GACRQ,SAAA,CAAUP,IAAA,KAAS,YACjBO,SAAA,CAAUR,UAAA,GACV,CAAC;EAEP,MAAMS,KAAA,GAAyD,EAAC;EAChEJ,MAAA,CAAOK,OAAA,CAASC,KAAA,IAAU;IACxBF,KAAA,CAAMG,IAAA,CAAKL,YAAA,CAAaI,KAAA,EAAOX,UAAU,CAAC;EAC5C,CAAC;EACD,OAAOX,iBAAA,CAAkBoB,KAAK;AAChC;AAKA,SAASF,aACPF,MAAA,EACAL,UAAA,EAC0C;EAC1C,IAAIK,MAAA,CAAOR,MAAA,GAAS,GAAG;IACrB,OAAON,eAAA,CAAgBc,MAAA,EAAQL,UAAU;EAC3C;EACA,OAAOV,UAAA,CAAWe,MAAA,CAAO,CAAC,GAAGL,UAAU;AACzC;AAGA,IAAOa,aAAA,GAAQpB,aAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}