{"ast":null,"code":"// index.ts\nimport { clone } from \"@turf/clone\";\nimport { distance } from \"@turf/distance\";\nimport { degreesToRadians, lengthToDegrees } from \"@turf/helpers\";\nimport RBush from \"rbush\";\nfunction clustersDbscan(points, maxDistance) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (options.mutate !== true) points = clone(points);\n  const minPoints = options.minPoints || 3;\n  const latDistanceInDegrees = lengthToDegrees(maxDistance, options.units);\n  var tree = new RBush(points.features.length);\n  var visited = points.features.map(_ => false);\n  var assigned = points.features.map(_ => false);\n  var isnoise = points.features.map(_ => false);\n  var clusterIds = points.features.map(_ => -1);\n  tree.load(points.features.map((point, index) => {\n    var [x, y] = point.geometry.coordinates;\n    return {\n      minX: x,\n      minY: y,\n      maxX: x,\n      maxY: y,\n      index\n    };\n  }));\n  const regionQuery = index => {\n    const point = points.features[index];\n    const [x, y] = point.geometry.coordinates;\n    const minY = Math.max(y - latDistanceInDegrees, -90);\n    const maxY = Math.min(y + latDistanceInDegrees, 90);\n    const lonDistanceInDegrees = function () {\n      if (minY < 0 && maxY > 0) {\n        return latDistanceInDegrees;\n      }\n      if (Math.abs(minY) < Math.abs(maxY)) {\n        return latDistanceInDegrees / Math.cos(degreesToRadians(maxY));\n      } else {\n        return latDistanceInDegrees / Math.cos(degreesToRadians(minY));\n      }\n    }();\n    const minX = Math.max(x - lonDistanceInDegrees, -360);\n    const maxX = Math.min(x + lonDistanceInDegrees, 360);\n    const bbox = {\n      minX,\n      minY,\n      maxX,\n      maxY\n    };\n    return tree.search(bbox).filter(neighbor => {\n      const neighborIndex = neighbor.index;\n      const neighborPoint = points.features[neighborIndex];\n      const distanceInKm = distance(point, neighborPoint, {\n        units: \"kilometers\"\n      });\n      return distanceInKm <= maxDistance;\n    });\n  };\n  const expandCluster = (clusteredId, neighbors) => {\n    for (var i = 0; i < neighbors.length; i++) {\n      var neighbor = neighbors[i];\n      const neighborIndex = neighbor.index;\n      if (!visited[neighborIndex]) {\n        visited[neighborIndex] = true;\n        const nextNeighbors = regionQuery(neighborIndex);\n        if (nextNeighbors.length >= minPoints) {\n          neighbors.push(...nextNeighbors);\n        }\n      }\n      if (!assigned[neighborIndex]) {\n        assigned[neighborIndex] = true;\n        clusterIds[neighborIndex] = clusteredId;\n      }\n    }\n  };\n  var nextClusteredId = 0;\n  points.features.forEach((_, index) => {\n    if (visited[index]) return;\n    const neighbors = regionQuery(index);\n    if (neighbors.length >= minPoints) {\n      const clusteredId = nextClusteredId;\n      nextClusteredId++;\n      visited[index] = true;\n      expandCluster(clusteredId, neighbors);\n    } else {\n      isnoise[index] = true;\n    }\n  });\n  points.features.forEach((_, index) => {\n    var clusterPoint = points.features[index];\n    if (!clusterPoint.properties) {\n      clusterPoint.properties = {};\n    }\n    if (clusterIds[index] >= 0) {\n      clusterPoint.properties.dbscan = isnoise[index] ? \"edge\" : \"core\";\n      clusterPoint.properties.cluster = clusterIds[index];\n    } else {\n      clusterPoint.properties.dbscan = \"noise\";\n    }\n  });\n  return points;\n}\nvar index_default = clustersDbscan;\nexport { clustersDbscan, index_default as default };","map":{"version":3,"names":["clone","distance","degreesToRadians","lengthToDegrees","RBush","clustersDbscan","points","maxDistance","options","arguments","length","undefined","mutate","minPoints","latDistanceInDegrees","units","tree","features","visited","map","_","assigned","isnoise","clusterIds","load","point","index","x","y","geometry","coordinates","minX","minY","maxX","maxY","regionQuery","Math","max","min","lonDistanceInDegrees","abs","cos","bbox","search","filter","neighbor","neighborIndex","neighborPoint","distanceInKm","expandCluster","clusteredId","neighbors","i","nextNeighbors","push","nextClusteredId","forEach","clusterPoint","properties","dbscan","cluster","index_default"],"sources":["C:\\Users\\HP\\map-drawing-app\\node_modules\\@turf\\clusters-dbscan\\index.ts"],"sourcesContent":["import { GeoJsonProperties, FeatureCollection, Point } from \"geojson\";\nimport { clone } from \"@turf/clone\";\nimport { distance } from \"@turf/distance\";\nimport { degreesToRadians, lengthToDegrees, Units } from \"@turf/helpers\";\nimport RBush from \"rbush\";\n\n/**\n * Point classification within the cluster.\n *\n * @typedef {\"core\" | \"edge\" | \"noise\"} Dbscan\n */\ntype Dbscan = \"core\" | \"edge\" | \"noise\";\n\n/**\n * Properties assigned to each clustered point.\n *\n * @extends GeoJsonProperties\n * @typedef {object} DbscanProps\n * @property {Dbscan} [dbscan] type of point it has been classified as\n * @property {number} [cluster] associated clusterId\n */\ntype DbscanProps = GeoJsonProperties & {\n  dbscan?: Dbscan;\n  cluster?: number;\n};\n\n// Structure of a point in the spatial index\ntype IndexedPoint = {\n  minX: number;\n  minY: number;\n  maxX: number;\n  maxY: number;\n  index: number;\n};\n\n/**\n * Takes a set of {@link Point|points} and partition them into clusters according to {@link https://en.wikipedia.org/wiki/DBSCAN|DBSCAN's} data clustering algorithm.\n *\n * @function\n * @param {FeatureCollection<Point>} points to be clustered\n * @param {number} maxDistance Maximum Distance between any point of the cluster to generate the clusters (kilometers by default, see options)\n * @param {Object} [options={}] Optional parameters\n * @param {Units} [options.units=\"kilometers\"] in which `maxDistance` is expressed, Supports all valid Turf {@link https://turfjs.org/docs/api/types/Units Units}\n * @param {boolean} [options.mutate=false] Allows GeoJSON input to be mutated\n * @param {number} [options.minPoints=3] Minimum number of points to generate a single cluster,\n * points which do not meet this requirement will be classified as an 'edge' or 'noise'.\n * @returns {FeatureCollection<Point, DbscanProps>} Clustered Points with an additional two properties associated to each Feature:\n * - {number} cluster - the associated clusterId\n * - {string} dbscan - type of point it has been classified as ('core'|'edge'|'noise')\n * @example\n * // create random points with random z-values in their properties\n * var points = turf.randomPoint(100, {bbox: [0, 30, 20, 50]});\n * var maxDistance = 100;\n * var clustered = turf.clustersDbscan(points, maxDistance);\n *\n * //addToMap\n * var addToMap = [clustered];\n */\nfunction clustersDbscan(\n  points: FeatureCollection<Point>,\n  maxDistance: number,\n  options: {\n    units?: Units;\n    minPoints?: number;\n    mutate?: boolean;\n  } = {}\n): FeatureCollection<Point, DbscanProps> {\n  // Input validation being handled by Typescript\n  // collectionOf(points, 'Point', 'points must consist of a FeatureCollection of only Points');\n  // if (maxDistance === null || maxDistance === undefined) throw new Error('maxDistance is required');\n  // if (!(Math.sign(maxDistance) > 0)) throw new Error('maxDistance is invalid');\n  // if (!(minPoints === undefined || minPoints === null || Math.sign(minPoints) > 0)) throw new Error('options.minPoints is invalid');\n\n  // Clone points to prevent any mutations\n  if (options.mutate !== true) points = clone(points);\n\n  // Defaults\n  const minPoints = options.minPoints || 3;\n\n  // Calculate the distance in degrees for region queries\n  const latDistanceInDegrees = lengthToDegrees(maxDistance, options.units);\n\n  // Create a spatial index\n  var tree = new RBush(points.features.length);\n\n  // Keeps track of whether a point has been visited or not.\n  var visited = points.features.map((_) => false);\n\n  // Keeps track of whether a point is assigned to a cluster or not.\n  var assigned = points.features.map((_) => false);\n\n  // Keeps track of whether a point is noise|edge or not.\n  var isnoise = points.features.map((_) => false);\n\n  // Keeps track of the clusterId for each point\n  var clusterIds: number[] = points.features.map((_) => -1);\n\n  // Index each point for spatial queries\n  tree.load(\n    points.features.map((point, index) => {\n      var [x, y] = point.geometry.coordinates;\n      return {\n        minX: x,\n        minY: y,\n        maxX: x,\n        maxY: y,\n        index: index,\n      } as IndexedPoint;\n    })\n  );\n\n  // Function to find neighbors of a point within a given distance\n  const regionQuery = (index: number): IndexedPoint[] => {\n    const point = points.features[index];\n    const [x, y] = point.geometry.coordinates;\n\n    const minY = Math.max(y - latDistanceInDegrees, -90.0);\n    const maxY = Math.min(y + latDistanceInDegrees, 90.0);\n\n    const lonDistanceInDegrees = (function () {\n      // Handle the case where the bounding box crosses the poles\n      if (minY < 0 && maxY > 0) {\n        return latDistanceInDegrees;\n      }\n      if (Math.abs(minY) < Math.abs(maxY)) {\n        return latDistanceInDegrees / Math.cos(degreesToRadians(maxY));\n      } else {\n        return latDistanceInDegrees / Math.cos(degreesToRadians(minY));\n      }\n    })();\n\n    const minX = Math.max(x - lonDistanceInDegrees, -360.0);\n    const maxX = Math.min(x + lonDistanceInDegrees, 360.0);\n\n    // Calculate the bounding box for the region query\n    const bbox = { minX, minY, maxX, maxY };\n    return (tree.search(bbox) as ReadonlyArray<IndexedPoint>).filter(\n      (neighbor) => {\n        const neighborIndex = neighbor.index;\n        const neighborPoint = points.features[neighborIndex];\n        const distanceInKm = distance(point, neighborPoint, {\n          units: \"kilometers\",\n        });\n        return distanceInKm <= maxDistance;\n      }\n    );\n  };\n\n  // Function to expand a cluster\n  const expandCluster = (clusteredId: number, neighbors: IndexedPoint[]) => {\n    for (var i = 0; i < neighbors.length; i++) {\n      var neighbor = neighbors[i];\n      const neighborIndex = neighbor.index;\n      if (!visited[neighborIndex]) {\n        visited[neighborIndex] = true;\n        const nextNeighbors = regionQuery(neighborIndex);\n        if (nextNeighbors.length >= minPoints) {\n          neighbors.push(...nextNeighbors);\n        }\n      }\n      if (!assigned[neighborIndex]) {\n        assigned[neighborIndex] = true;\n        clusterIds[neighborIndex] = clusteredId;\n      }\n    }\n  };\n\n  // Main DBSCAN clustering algorithm\n  var nextClusteredId = 0;\n  points.features.forEach((_, index) => {\n    if (visited[index]) return;\n    const neighbors = regionQuery(index);\n    if (neighbors.length >= minPoints) {\n      const clusteredId = nextClusteredId;\n      nextClusteredId++;\n      visited[index] = true;\n      expandCluster(clusteredId, neighbors);\n    } else {\n      isnoise[index] = true;\n    }\n  });\n\n  // Assign DBSCAN properties to each point\n  points.features.forEach((_, index) => {\n    var clusterPoint = points.features[index];\n    if (!clusterPoint.properties) {\n      clusterPoint.properties = {};\n    }\n\n    if (clusterIds[index] >= 0) {\n      clusterPoint.properties.dbscan = isnoise[index] ? \"edge\" : \"core\";\n      clusterPoint.properties.cluster = clusterIds[index];\n    } else {\n      clusterPoint.properties.dbscan = \"noise\";\n    }\n  });\n\n  return points as FeatureCollection<Point, DbscanProps>;\n}\n\nexport { Dbscan, DbscanProps, clustersDbscan };\nexport default clustersDbscan;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}