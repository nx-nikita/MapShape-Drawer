{"ast":null,"code":"// index.ts\nimport { circle } from \"@turf/circle\";\nimport { destination } from \"@turf/destination\";\nimport { lineString } from \"@turf/helpers\";\nfunction lineArc(center, radius, bearing1, bearing2) {\n  let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  const steps = options.steps || 64;\n  const angle1 = convertAngleTo360(bearing1);\n  const angle2 = convertAngleTo360(bearing2);\n  const properties = !Array.isArray(center) && center.type === \"Feature\" ? center.properties : {};\n  if (angle1 === angle2) {\n    return lineString(circle(center, radius, options).geometry.coordinates[0], properties);\n  }\n  const arcStartDegree = angle1;\n  const arcEndDegree = angle1 < angle2 ? angle2 : angle2 + 360;\n  let alpha = arcStartDegree;\n  const coordinates = [];\n  let i = 0;\n  const arcStep = (arcEndDegree - arcStartDegree) / steps;\n  while (alpha <= arcEndDegree) {\n    coordinates.push(destination(center, radius, alpha, options).geometry.coordinates);\n    i++;\n    alpha = arcStartDegree + i * arcStep;\n  }\n  return lineString(coordinates, properties);\n}\nfunction convertAngleTo360(alpha) {\n  let beta = alpha % 360;\n  if (beta < 0) {\n    beta += 360;\n  }\n  return beta;\n}\nvar index_default = lineArc;\nexport { index_default as default, lineArc };","map":{"version":3,"names":["circle","destination","lineString","lineArc","center","radius","bearing1","bearing2","options","arguments","length","undefined","steps","angle1","convertAngleTo360","angle2","properties","Array","isArray","type","geometry","coordinates","arcStartDegree","arcEndDegree","alpha","i","arcStep","push","beta","index_default"],"sources":["C:\\Users\\HP\\map-drawing-app\\node_modules\\@turf\\line-arc\\index.ts"],"sourcesContent":["import { Feature, LineString } from \"geojson\";\nimport { circle } from \"@turf/circle\";\nimport { destination } from \"@turf/destination\";\nimport { Coord, lineString, Units } from \"@turf/helpers\";\n\n/**\n * Creates a circular arc, of a circle of the given radius and center point, between bearing1 and bearing2;\n * 0 bearing is North of center point, positive clockwise.\n *\n * @function\n * @param {Coord} center center point\n * @param {number} radius radius of the circle\n * @param {number} bearing1 angle, in decimal degrees, of the first radius of the arc\n * @param {number} bearing2 angle, in decimal degrees, of the second radius of the arc\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.steps=64] number of steps (straight segments) that will constitute the arc\n * @param {Units} [options.units='kilometers'] Supports all valid Turf {@link https://turfjs.org/docs/api/types/Units Units}.\n * @returns {Feature<LineString>} line arc\n * @example\n * var center = turf.point([-75, 40]);\n * var radius = 5;\n * var bearing1 = 25;\n * var bearing2 = 47;\n *\n * var arc = turf.lineArc(center, radius, bearing1, bearing2);\n *\n * //addToMap\n * var addToMap = [center, arc]\n */\nfunction lineArc(\n  center: Coord,\n  radius: number,\n  bearing1: number,\n  bearing2: number,\n  options: {\n    steps?: number;\n    units?: Units;\n  } = {}\n): Feature<LineString> {\n  // default params\n  const steps = options.steps || 64;\n\n  const angle1 = convertAngleTo360(bearing1);\n  const angle2 = convertAngleTo360(bearing2);\n  const properties =\n    !Array.isArray(center) && center.type === \"Feature\"\n      ? center.properties\n      : {};\n\n  // handle angle parameters\n  if (angle1 === angle2) {\n    return lineString(\n      circle(center, radius, options).geometry.coordinates[0],\n      properties\n    );\n  }\n  const arcStartDegree = angle1;\n  const arcEndDegree = angle1 < angle2 ? angle2 : angle2 + 360;\n\n  let alpha = arcStartDegree;\n  const coordinates = [];\n  let i = 0;\n  // How many degrees we'll swing around between each step.\n  const arcStep = (arcEndDegree - arcStartDegree) / steps;\n  // Add coords to the list, increasing the angle from our start bearing\n  // (alpha) by arcStep degrees until we reach the end bearing.\n  while (alpha <= arcEndDegree) {\n    coordinates.push(\n      destination(center, radius, alpha, options).geometry.coordinates\n    );\n    i++;\n    alpha = arcStartDegree + i * arcStep;\n  }\n  return lineString(coordinates, properties);\n}\n\n/**\n * Takes any angle in  degrees\n * and returns a valid angle between 0-360 degrees\n *\n * @private\n * @param {number} alpha angle between -180-180 degrees\n * @returns {number} angle between 0-360 degrees\n */\nfunction convertAngleTo360(alpha: number) {\n  let beta = alpha % 360;\n  if (beta < 0) {\n    beta += 360;\n  }\n  return beta;\n}\n\nexport { lineArc };\nexport default lineArc;\n"],"mappings":";AACA,SAASA,MAAA,QAAc;AACvB,SAASC,WAAA,QAAmB;AAC5B,SAAgBC,UAAA,QAAyB;AA0BzC,SAASC,QACPC,MAAA,EACAC,MAAA,EACAC,QAAA,EACAC,QAAA,EAKqB;EAAA,IAJrBC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAGI,CAAC;EAGL,MAAMG,KAAA,GAAQJ,OAAA,CAAQI,KAAA,IAAS;EAE/B,MAAMC,MAAA,GAASC,iBAAA,CAAkBR,QAAQ;EACzC,MAAMS,MAAA,GAASD,iBAAA,CAAkBP,QAAQ;EACzC,MAAMS,UAAA,GACJ,CAACC,KAAA,CAAMC,OAAA,CAAQd,MAAM,KAAKA,MAAA,CAAOe,IAAA,KAAS,YACtCf,MAAA,CAAOY,UAAA,GACP,CAAC;EAGP,IAAIH,MAAA,KAAWE,MAAA,EAAQ;IACrB,OAAOb,UAAA,CACLF,MAAA,CAAOI,MAAA,EAAQC,MAAA,EAAQG,OAAO,EAAEY,QAAA,CAASC,WAAA,CAAY,CAAC,GACtDL,UACF;EACF;EACA,MAAMM,cAAA,GAAiBT,MAAA;EACvB,MAAMU,YAAA,GAAeV,MAAA,GAASE,MAAA,GAASA,MAAA,GAASA,MAAA,GAAS;EAEzD,IAAIS,KAAA,GAAQF,cAAA;EACZ,MAAMD,WAAA,GAAc,EAAC;EACrB,IAAII,CAAA,GAAI;EAER,MAAMC,OAAA,IAAWH,YAAA,GAAeD,cAAA,IAAkBV,KAAA;EAGlD,OAAOY,KAAA,IAASD,YAAA,EAAc;IAC5BF,WAAA,CAAYM,IAAA,CACV1B,WAAA,CAAYG,MAAA,EAAQC,MAAA,EAAQmB,KAAA,EAAOhB,OAAO,EAAEY,QAAA,CAASC,WACvD;IACAI,CAAA;IACAD,KAAA,GAAQF,cAAA,GAAiBG,CAAA,GAAIC,OAAA;EAC/B;EACA,OAAOxB,UAAA,CAAWmB,WAAA,EAAaL,UAAU;AAC3C;AAUA,SAASF,kBAAkBU,KAAA,EAAe;EACxC,IAAII,IAAA,GAAOJ,KAAA,GAAQ;EACnB,IAAII,IAAA,GAAO,GAAG;IACZA,IAAA,IAAQ;EACV;EACA,OAAOA,IAAA;AACT;AAGA,IAAOC,aAAA,GAAQ1B,OAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}