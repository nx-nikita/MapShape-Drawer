{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\n// index.ts\nimport { bbox } from \"@turf/bbox\";\nimport { coordEach } from \"@turf/meta\";\nimport { collectionOf as collectionOf2 } from \"@turf/invariant\";\nimport { multiLineString, featureCollection, isObject as isObject2 } from \"@turf/helpers\";\n\n// lib/grid-to-matrix.js\nimport { getCoords, collectionOf } from \"@turf/invariant\";\nimport { featureEach } from \"@turf/meta\";\nimport { isObject } from \"@turf/helpers\";\nfunction gridToMatrix(grid, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var zProperty = options.zProperty || \"elevation\";\n  var flip = options.flip;\n  var flags = options.flags;\n  collectionOf(grid, \"Point\", \"input must contain Points\");\n  var pointsMatrix = sortPointsByLatLng(grid, flip);\n  var matrix = [];\n  for (var r = 0; r < pointsMatrix.length; r++) {\n    var pointRow = pointsMatrix[r];\n    var row = [];\n    for (var c = 0; c < pointRow.length; c++) {\n      var point = pointRow[c];\n      if (point.properties[zProperty]) row.push(point.properties[zProperty]);else row.push(0);\n      if (flags === true) point.properties.matrixPosition = [r, c];\n    }\n    matrix.push(row);\n  }\n  return matrix;\n}\nfunction sortPointsByLatLng(points, flip) {\n  var pointsByLatitude = {};\n  featureEach(points, function (point) {\n    var lat = getCoords(point)[1];\n    if (!pointsByLatitude[lat]) pointsByLatitude[lat] = [];\n    pointsByLatitude[lat].push(point);\n  });\n  var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function (lat) {\n    var row = pointsByLatitude[lat];\n    var rowOrderedByLongitude = row.sort(function (a, b) {\n      return getCoords(a)[0] - getCoords(b)[0];\n    });\n    return rowOrderedByLongitude;\n  });\n  var pointMatrix = orderedRowsByLatitude.sort(function (a, b) {\n    if (flip) return getCoords(a[0])[1] - getCoords(b[0])[1];else return getCoords(b[0])[1] - getCoords(a[0])[1];\n  });\n  return pointMatrix;\n}\n\n// index.ts\nfunction isolines(pointGrid, breaks, options) {\n  options = options || {};\n  if (!isObject2(options)) throw new Error(\"options is invalid\");\n  const zProperty = options.zProperty || \"elevation\";\n  const commonProperties = options.commonProperties || {};\n  const breaksProperties = options.breaksProperties || [];\n  collectionOf2(pointGrid, \"Point\", \"Input must contain Points\");\n  if (!breaks) throw new Error(\"breaks is required\");\n  if (!Array.isArray(breaks)) throw new Error(\"breaks must be an Array\");\n  if (!isObject2(commonProperties)) throw new Error(\"commonProperties must be an Object\");\n  if (!Array.isArray(breaksProperties)) throw new Error(\"breaksProperties must be an Array\");\n  const matrix = gridToMatrix(pointGrid, {\n    zProperty,\n    flip: true\n  });\n  const dx = matrix[0].length;\n  if (matrix.length < 2 || dx < 2) {\n    throw new Error(\"Matrix of points must be at least 2x2\");\n  }\n  for (let i = 1; i < matrix.length; i++) {\n    if (matrix[i].length !== dx) {\n      throw new Error(\"Matrix of points is not uniform in the x dimension\");\n    }\n  }\n  const createdIsoLines = createIsoLines(matrix, breaks, zProperty, commonProperties, breaksProperties);\n  const scaledIsolines = rescaleIsolines(createdIsoLines, matrix, pointGrid);\n  return featureCollection(scaledIsolines);\n}\nfunction createIsoLines(matrix, breaks, zProperty, commonProperties, breaksProperties) {\n  const results = [];\n  for (let i = 0; i < breaks.length; i++) {\n    const threshold = +breaks[i];\n    const properties = __spreadValues(__spreadValues({}, commonProperties), breaksProperties[i]);\n    properties[zProperty] = threshold;\n    const isoline = multiLineString(isoContours(matrix, threshold), properties);\n    results.push(isoline);\n  }\n  return results;\n}\nfunction isoContours(matrix, threshold) {\n  const segments = [];\n  const dy = matrix.length;\n  const dx = matrix[0].length;\n  for (let y = 0; y < dy - 1; y++) {\n    for (let x = 0; x < dx - 1; x++) {\n      const tr = matrix[y + 1][x + 1];\n      const br = matrix[y][x + 1];\n      const bl = matrix[y][x];\n      const tl = matrix[y + 1][x];\n      let grid = (tl >= threshold ? 8 : 0) | (tr >= threshold ? 4 : 0) | (br >= threshold ? 2 : 0) | (bl >= threshold ? 1 : 0);\n      switch (grid) {\n        case 0:\n          continue;\n        case 1:\n          segments.push([[x + frac(bl, br), y], [x, y + frac(bl, tl)]]);\n          break;\n        case 2:\n          segments.push([[x + 1, y + frac(br, tr)], [x + frac(bl, br), y]]);\n          break;\n        case 3:\n          segments.push([[x + 1, y + frac(br, tr)], [x, y + frac(bl, tl)]]);\n          break;\n        case 4:\n          segments.push([[x + frac(tl, tr), y + 1], [x + 1, y + frac(br, tr)]]);\n          break;\n        case 5:\n          {\n            const avg = (tl + tr + br + bl) / 4;\n            const above = avg >= threshold;\n            if (above) {\n              segments.push([[x + frac(tl, tr), y + 1], [x, y + frac(bl, tl)]], [[x + frac(bl, br), y], [x + 1, y + frac(br, tr)]]);\n            } else {\n              segments.push([[x + frac(tl, tr), y + 1], [x + 1, y + frac(br, tr)]], [[x + frac(bl, br), y], [x, y + frac(bl, tl)]]);\n            }\n            break;\n          }\n        case 6:\n          segments.push([[x + frac(tl, tr), y + 1], [x + frac(bl, br), y]]);\n          break;\n        case 7:\n          segments.push([[x + frac(tl, tr), y + 1], [x, y + frac(bl, tl)]]);\n          break;\n        case 8:\n          segments.push([[x, y + frac(bl, tl)], [x + frac(tl, tr), y + 1]]);\n          break;\n        case 9:\n          segments.push([[x + frac(bl, br), y], [x + frac(tl, tr), y + 1]]);\n          break;\n        case 10:\n          {\n            const avg = (tl + tr + br + bl) / 4;\n            const above = avg >= threshold;\n            if (above) {\n              segments.push([[x, y + frac(bl, tl)], [x + frac(bl, br), y]], [[x + 1, y + frac(br, tr)], [x + frac(tl, tr), y + 1]]);\n            } else {\n              segments.push([[x, y + frac(bl, tl)], [x + frac(tl, tr), y + 1]], [[x + 1, y + frac(br, tr)], [x + frac(bl, br), y]]);\n            }\n            break;\n          }\n        case 11:\n          segments.push([[x + 1, y + frac(br, tr)], [x + frac(tl, tr), y + 1]]);\n          break;\n        case 12:\n          segments.push([[x, y + frac(bl, tl)], [x + 1, y + frac(br, tr)]]);\n          break;\n        case 13:\n          segments.push([[x + frac(bl, br), y], [x + 1, y + frac(br, tr)]]);\n          break;\n        case 14:\n          segments.push([[x, y + frac(bl, tl)], [x + frac(bl, br), y]]);\n          break;\n        case 15:\n          continue;\n      }\n    }\n  }\n  const contours = [];\n  while (segments.length > 0) {\n    const contour = [...segments.shift()];\n    contours.push(contour);\n    let found;\n    do {\n      found = false;\n      for (let i = 0; i < segments.length; i++) {\n        const segment = segments[i];\n        if (segment[0][0] === contour[contour.length - 1][0] && segment[0][1] === contour[contour.length - 1][1]) {\n          found = true;\n          contour.push(segment[1]);\n          segments.splice(i, 1);\n          break;\n        }\n        if (segment[1][0] === contour[0][0] && segment[1][1] === contour[0][1]) {\n          found = true;\n          contour.unshift(segment[0]);\n          segments.splice(i, 1);\n          break;\n        }\n      }\n    } while (found);\n  }\n  return contours;\n  function frac(z0, z1) {\n    if (z0 === z1) {\n      return 0.5;\n    }\n    let t = (threshold - z0) / (z1 - z0);\n    return t > 1 ? 1 : t < 0 ? 0 : t;\n  }\n}\nfunction rescaleIsolines(createdIsoLines, matrix, points) {\n  const gridBbox = bbox(points);\n  const originalWidth = gridBbox[2] - gridBbox[0];\n  const originalHeigth = gridBbox[3] - gridBbox[1];\n  const x0 = gridBbox[0];\n  const y0 = gridBbox[1];\n  const matrixWidth = matrix[0].length - 1;\n  const matrixHeight = matrix.length - 1;\n  const scaleX = originalWidth / matrixWidth;\n  const scaleY = originalHeigth / matrixHeight;\n  const resize = point => {\n    point[0] = point[0] * scaleX + x0;\n    point[1] = point[1] * scaleY + y0;\n  };\n  createdIsoLines.forEach(isoline => {\n    coordEach(isoline, resize);\n  });\n  return createdIsoLines;\n}\nvar index_default = isolines;\nexport { index_default as default, isolines };","map":{"version":3,"names":["bbox","coordEach","collectionOf","collectionOf2","multiLineString","featureCollection","isObject","isObject2","getCoords","featureEach","gridToMatrix","grid","options","Error","zProperty","flip","flags","pointsMatrix","sortPointsByLatLng","matrix","r","length","pointRow","row","c","point","properties","push","matrixPosition","points","pointsByLatitude","lat","orderedRowsByLatitude","Object","keys","map","rowOrderedByLongitude","sort","a","b","pointMatrix","isolines","pointGrid","breaks","commonProperties","breaksProperties","Array","isArray","dx","i","createdIsoLines","createIsoLines","scaledIsolines","rescaleIsolines","results","threshold","__spreadValues","isoline","isoContours","segments","dy","y","x","tr","br","bl","tl","frac","avg","above","contours","contour","shift","found","segment","splice","unshift","z0","z1","t","gridBbox","originalWidth","originalHeigth","x0","y0","matrixWidth","matrixHeight","scaleX","scaleY","resize","forEach","index_default"],"sources":["C:\\Users\\HP\\map-drawing-app\\node_modules\\@turf\\isolines\\index.ts","C:\\Users\\HP\\map-drawing-app\\node_modules\\@turf\\isolines\\lib\\grid-to-matrix.js"],"sourcesContent":["import { bbox } from \"@turf/bbox\";\nimport { coordEach } from \"@turf/meta\";\nimport { collectionOf } from \"@turf/invariant\";\nimport { multiLineString, featureCollection, isObject } from \"@turf/helpers\";\nimport { gridToMatrix } from \"./lib/grid-to-matrix.js\";\nimport {\n  FeatureCollection,\n  Point,\n  MultiLineString,\n  Feature,\n  GeoJsonProperties,\n  Position,\n} from \"geojson\";\n\n/**\n * Takes a grid {@link FeatureCollection} of {@link Point} features with z-values and an array of\n * value breaks and generates [isolines](https://en.wikipedia.org/wiki/Contour_line).\n *\n * @function\n * @param {FeatureCollection<Point>} pointGrid input points - must be square or rectangular and already gridded. That is, to have consistent x and y dimensions and be at least 2x2 in size.\n * @param {Array<number>} breaks values of `zProperty` where to draw isolines\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled\n * @param {Object} [options.commonProperties={}] GeoJSON properties passed to ALL isolines\n * @param {Array<Object>} [options.breaksProperties=[]] GeoJSON properties passed, in order, to the correspondent isoline;\n * the breaks array will define the order in which the isolines are created\n * @returns {FeatureCollection<MultiLineString>} a FeatureCollection of {@link MultiLineString} features representing isolines\n * @example\n * // create a grid of points with random z-values in their properties\n * var extent = [0, 30, 20, 50];\n * var cellWidth = 100;\n * var pointGrid = turf.pointGrid(extent, cellWidth, {units: 'miles'});\n *\n * for (var i = 0; i < pointGrid.features.length; i++) {\n *     pointGrid.features[i].properties.temperature = Math.random() * 10;\n * }\n * var breaks = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n *\n * var lines = turf.isolines(pointGrid, breaks, {zProperty: 'temperature'});\n *\n * //addToMap\n * var addToMap = [lines];\n */\nfunction isolines(\n  pointGrid: FeatureCollection<Point>,\n  breaks: number[],\n  options?: {\n    zProperty?: string;\n    commonProperties?: GeoJsonProperties;\n    breaksProperties?: GeoJsonProperties[];\n  }\n) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  const zProperty = options.zProperty || \"elevation\";\n  const commonProperties = options.commonProperties || {};\n  const breaksProperties = options.breaksProperties || [];\n\n  // Input validation\n  collectionOf(pointGrid, \"Point\", \"Input must contain Points\");\n  if (!breaks) throw new Error(\"breaks is required\");\n  if (!Array.isArray(breaks)) throw new Error(\"breaks must be an Array\");\n  if (!isObject(commonProperties))\n    throw new Error(\"commonProperties must be an Object\");\n  if (!Array.isArray(breaksProperties))\n    throw new Error(\"breaksProperties must be an Array\");\n\n  // Isoline methods\n  const matrix = gridToMatrix(pointGrid, { zProperty: zProperty, flip: true });\n\n  // A quick note on what 'top' and 'bottom' mean in coordinate system of `matrix`:\n  // Remember that the southern hemisphere is represented by negative numbers,\n  // so a matrix Y of 0 is actually the *bottom*, and a Y of dy - 1 is the *top*.\n\n  // check that the resulting matrix has consistent x and y dimensions and\n  // has at least a 2x2 size so that we can actually build grid squares\n  const dx = matrix[0].length;\n  if (matrix.length < 2 || dx < 2) {\n    throw new Error(\"Matrix of points must be at least 2x2\");\n  }\n  for (let i = 1; i < matrix.length; i++) {\n    if (matrix[i].length !== dx) {\n      throw new Error(\"Matrix of points is not uniform in the x dimension\");\n    }\n  }\n\n  const createdIsoLines = createIsoLines(\n    matrix,\n    breaks,\n    zProperty,\n    commonProperties,\n    breaksProperties\n  );\n  const scaledIsolines = rescaleIsolines(createdIsoLines, matrix, pointGrid);\n\n  return featureCollection(scaledIsolines);\n}\n\n/**\n * Creates the isolines lines (featuresCollection of MultiLineString features) from the 2D data grid\n *\n * Marchingsquares process the grid data as a 3D representation of a function on a 2D plane, therefore it\n * assumes the points (x-y coordinates) are one 'unit' distance. The result of the isolines function needs to be\n * rescaled, with turfjs, to the original area and proportions on the map\n *\n * @private\n * @param {Array<Array<number>>} matrix Grid Data\n * @param {Array<number>} breaks BreakProps\n * @param {string} zProperty name of the z-values property\n * @param {Object} [commonProperties={}] GeoJSON properties passed to ALL isolines\n * @param {Object} [breaksProperties=[]] GeoJSON properties passed to the correspondent isoline\n * @returns {Array<MultiLineString>} isolines\n */\nfunction createIsoLines(\n  matrix: number[][],\n  breaks: number[],\n  zProperty: string,\n  commonProperties: GeoJsonProperties,\n  breaksProperties: GeoJsonProperties[]\n): Feature<MultiLineString>[] {\n  const results = [];\n  for (let i = 0; i < breaks.length; i++) {\n    const threshold = +breaks[i]; // make sure it's a number\n\n    const properties = { ...commonProperties, ...breaksProperties[i] };\n    properties[zProperty] = threshold;\n    const isoline = multiLineString(isoContours(matrix, threshold), properties);\n\n    results.push(isoline);\n  }\n  return results;\n}\n\nfunction isoContours(\n  matrix: ReadonlyArray<ReadonlyArray<number>>,\n  threshold: number\n): Position[][] {\n  // see https://en.wikipedia.org/wiki/Marching_squares\n  const segments: [Position, Position][] = [];\n\n  const dy = matrix.length;\n  const dx = matrix[0].length;\n\n  for (let y = 0; y < dy - 1; y++) {\n    for (let x = 0; x < dx - 1; x++) {\n      const tr = matrix[y + 1][x + 1];\n      const br = matrix[y][x + 1];\n      const bl = matrix[y][x];\n      const tl = matrix[y + 1][x];\n\n      let grid =\n        (tl >= threshold ? 8 : 0) |\n        (tr >= threshold ? 4 : 0) |\n        (br >= threshold ? 2 : 0) |\n        (bl >= threshold ? 1 : 0);\n\n      switch (grid) {\n        case 0:\n          continue;\n        case 1:\n          segments.push([\n            [x + frac(bl, br), y],\n            [x, y + frac(bl, tl)],\n          ]);\n          break;\n        case 2:\n          segments.push([\n            [x + 1, y + frac(br, tr)],\n            [x + frac(bl, br), y],\n          ]);\n          break;\n        case 3:\n          segments.push([\n            [x + 1, y + frac(br, tr)],\n            [x, y + frac(bl, tl)],\n          ]);\n          break;\n        case 4:\n          segments.push([\n            [x + frac(tl, tr), y + 1],\n            [x + 1, y + frac(br, tr)],\n          ]);\n          break;\n        case 5: {\n          // use the average of the 4 corners to differentiate the saddle case and correctly honor the counter-clockwise winding\n          const avg = (tl + tr + br + bl) / 4;\n          const above = avg >= threshold;\n\n          if (above) {\n            segments.push(\n              [\n                [x + frac(tl, tr), y + 1],\n                [x, y + frac(bl, tl)],\n              ],\n              [\n                [x + frac(bl, br), y],\n                [x + 1, y + frac(br, tr)],\n              ]\n            );\n          } else {\n            segments.push(\n              [\n                [x + frac(tl, tr), y + 1],\n                [x + 1, y + frac(br, tr)],\n              ],\n              [\n                [x + frac(bl, br), y],\n                [x, y + frac(bl, tl)],\n              ]\n            );\n          }\n          break;\n        }\n        case 6:\n          segments.push([\n            [x + frac(tl, tr), y + 1],\n            [x + frac(bl, br), y],\n          ]);\n          break;\n        case 7:\n          segments.push([\n            [x + frac(tl, tr), y + 1],\n            [x, y + frac(bl, tl)],\n          ]);\n          break;\n        case 8:\n          segments.push([\n            [x, y + frac(bl, tl)],\n            [x + frac(tl, tr), y + 1],\n          ]);\n          break;\n        case 9:\n          segments.push([\n            [x + frac(bl, br), y],\n            [x + frac(tl, tr), y + 1],\n          ]);\n          break;\n        case 10: {\n          const avg = (tl + tr + br + bl) / 4;\n          const above = avg >= threshold;\n\n          if (above) {\n            segments.push(\n              [\n                [x, y + frac(bl, tl)],\n                [x + frac(bl, br), y],\n              ],\n              [\n                [x + 1, y + frac(br, tr)],\n                [x + frac(tl, tr), y + 1],\n              ]\n            );\n          } else {\n            segments.push(\n              [\n                [x, y + frac(bl, tl)],\n                [x + frac(tl, tr), y + 1],\n              ],\n              [\n                [x + 1, y + frac(br, tr)],\n                [x + frac(bl, br), y],\n              ]\n            );\n          }\n          break;\n        }\n        case 11:\n          segments.push([\n            [x + 1, y + frac(br, tr)],\n            [x + frac(tl, tr), y + 1],\n          ]);\n          break;\n        case 12:\n          segments.push([\n            [x, y + frac(bl, tl)],\n            [x + 1, y + frac(br, tr)],\n          ]);\n          break;\n        case 13:\n          segments.push([\n            [x + frac(bl, br), y],\n            [x + 1, y + frac(br, tr)],\n          ]);\n          break;\n        case 14:\n          segments.push([\n            [x, y + frac(bl, tl)],\n            [x + frac(bl, br), y],\n          ]);\n          break;\n        case 15:\n          // all above\n          continue;\n      }\n    }\n  }\n\n  const contours: Position[][] = [];\n\n  while (segments.length > 0) {\n    const contour: Position[] = [...segments.shift()!];\n    contours.push(contour);\n\n    let found: boolean;\n    do {\n      found = false;\n      for (let i = 0; i < segments.length; i++) {\n        const segment = segments[i];\n        // add the segment's end point to the end of the contour\n        if (\n          segment[0][0] === contour[contour.length - 1][0] &&\n          segment[0][1] === contour[contour.length - 1][1]\n        ) {\n          found = true;\n          contour.push(segment[1]);\n          segments.splice(i, 1);\n          break;\n        }\n        // add the segment's start point to the start of the contour\n        if (\n          segment[1][0] === contour[0][0] &&\n          segment[1][1] === contour[0][1]\n        ) {\n          found = true;\n          contour.unshift(segment[0]);\n          segments.splice(i, 1);\n          break;\n        }\n      }\n    } while (found);\n  }\n\n  return contours;\n\n  // get the linear interpolation fraction of how far z is between z0 and z1\n  // See https://github.com/fschutt/marching-squares/blob/master/src/lib.rs\n  function frac(z0: number, z1: number): number {\n    if (z0 === z1) {\n      return 0.5;\n    }\n\n    let t = (threshold - z0) / (z1 - z0);\n    return t > 1 ? 1 : t < 0 ? 0 : t;\n  }\n}\n\n/**\n * Translates and scales isolines\n *\n * @private\n * @param {Array<MultiLineString>} createdIsoLines to be rescaled\n * @param {Array<Array<number>>} matrix Grid Data\n * @param {Object} points Points by Latitude\n * @returns {Array<MultiLineString>} isolines\n */\nfunction rescaleIsolines(\n  createdIsoLines: Feature<MultiLineString>[],\n  matrix: number[][],\n  points: FeatureCollection<Point>\n) {\n  // get dimensions (on the map) of the original grid\n  const gridBbox = bbox(points); // [ minX, minY, maxX, maxY ]\n  const originalWidth = gridBbox[2] - gridBbox[0];\n  const originalHeigth = gridBbox[3] - gridBbox[1];\n\n  // get origin, which is the first point of the last row on the rectangular data on the map\n  const x0 = gridBbox[0];\n  const y0 = gridBbox[1];\n\n  // get number of cells per side\n  const matrixWidth = matrix[0].length - 1;\n  const matrixHeight = matrix.length - 1;\n\n  // calculate the scaling factor between matrix and rectangular grid on the map\n  const scaleX = originalWidth / matrixWidth;\n  const scaleY = originalHeigth / matrixHeight;\n\n  const resize = (point: number[]) => {\n    point[0] = point[0] * scaleX + x0;\n    point[1] = point[1] * scaleY + y0;\n  };\n\n  // resize and shift each point/line of the createdIsoLines\n  createdIsoLines.forEach((isoline) => {\n    coordEach(isoline, resize);\n  });\n  return createdIsoLines;\n}\n\nexport { isolines };\nexport default isolines;\n","import { getCoords, collectionOf } from \"@turf/invariant\";\nimport { featureEach } from \"@turf/meta\";\nimport { isObject } from \"@turf/helpers\";\n\n/**\n * Takes a {@link Point} grid and returns a correspondent matrix {Array<Array<number>>}\n * of the 'property' values\n *\n * @name gridToMatrix\n * @param {FeatureCollection<Point>} grid of points\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled\n * @param {boolean} [options.flip=false] returns the matrix upside-down\n * @param {boolean} [options.flags=false] flags, adding a `matrixPosition` array field ([row, column]) to its properties,\n * the grid points with coordinates on the matrix\n * @returns {Array<Array<number>>} matrix of property values\n * @example\n *   var extent = [-70.823364, -33.553984, -70.473175, -33.302986];\n *   var cellSize = 3;\n *   var grid = turf.pointGrid(extent, cellSize);\n *   // add a random property to each point between 0 and 60\n *   for (var i = 0; i < grid.features.length; i++) {\n *     grid.features[i].properties.elevation = (Math.random() * 60);\n *   }\n *   gridToMatrix(grid);\n *   //= [\n *     [ 1, 13, 10,  9, 10, 13, 18],\n *     [34,  8,  5,  4,  5,  8, 13],\n *     [10,  5,  2,  1,  2,  5,  4],\n *     [ 0,  4, 56, 19,  1,  4,  9],\n *     [10,  5,  2,  1,  2,  5, 10],\n *     [57,  8,  5,  4,  5,  0, 57],\n *     [ 3, 13, 10,  9,  5, 13, 18],\n *     [18, 13, 10,  9, 78, 13, 18]\n *   ]\n */\nfunction gridToMatrix(grid, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var zProperty = options.zProperty || \"elevation\";\n  var flip = options.flip;\n  var flags = options.flags;\n\n  // validation\n  collectionOf(grid, \"Point\", \"input must contain Points\");\n\n  var pointsMatrix = sortPointsByLatLng(grid, flip);\n\n  var matrix = [];\n  // create property matrix from sorted points\n  // looping order matters here\n  for (var r = 0; r < pointsMatrix.length; r++) {\n    var pointRow = pointsMatrix[r];\n    var row = [];\n    for (var c = 0; c < pointRow.length; c++) {\n      var point = pointRow[c];\n      // Check if zProperty exist\n      if (point.properties[zProperty]) row.push(point.properties[zProperty]);\n      else row.push(0);\n      // add flags\n      if (flags === true) point.properties.matrixPosition = [r, c];\n    }\n    matrix.push(row);\n  }\n\n  return matrix;\n}\n\n/**\n * Sorts points by latitude and longitude, creating a 2-dimensional array of points\n *\n * @private\n * @param {FeatureCollection<Point>} points GeoJSON Point features\n * @param {boolean} [flip=false] returns the matrix upside-down\n * @returns {Array<Array<Point>>} points ordered by latitude and longitude\n */\nfunction sortPointsByLatLng(points, flip) {\n  var pointsByLatitude = {};\n\n  // divide points by rows with the same latitude\n  featureEach(points, function (point) {\n    var lat = getCoords(point)[1];\n    if (!pointsByLatitude[lat]) pointsByLatitude[lat] = [];\n    pointsByLatitude[lat].push(point);\n  });\n\n  // sort points (with the same latitude) by longitude\n  var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function (lat) {\n    var row = pointsByLatitude[lat];\n    var rowOrderedByLongitude = row.sort(function (a, b) {\n      return getCoords(a)[0] - getCoords(b)[0];\n    });\n    return rowOrderedByLongitude;\n  });\n\n  // sort rows (of points with the same latitude) by latitude\n  var pointMatrix = orderedRowsByLatitude.sort(function (a, b) {\n    if (flip) return getCoords(a[0])[1] - getCoords(b[0])[1];\n    else return getCoords(b[0])[1] - getCoords(a[0])[1];\n  });\n\n  return pointMatrix;\n}\n\nexport { gridToMatrix };\nexport default gridToMatrix;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}