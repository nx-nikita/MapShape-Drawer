{"ast":null,"code":"// index.ts\nimport { featureCollection, isNumber, isObject, lineString, point, polygon, validateBBox } from \"@turf/helpers\";\nfunction randomPosition(bbox) {\n  checkBBox(bbox);\n  return randomPositionUnchecked(bbox);\n}\nfunction randomPositionUnchecked(bbox) {\n  if (Array.isArray(bbox)) {\n    return coordInBBox(bbox);\n  }\n  if (bbox && bbox.bbox) {\n    return coordInBBox(bbox.bbox);\n  }\n  return [lon(), lat()];\n}\nfunction checkBBox(bbox) {\n  if (bbox == null) {\n    return;\n  } else if (Array.isArray(bbox)) {\n    validateBBox(bbox);\n  } else if (bbox.bbox != null) {\n    validateBBox(bbox.bbox);\n  }\n}\nfunction randomPoint(count) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  checkBBox(options.bbox);\n  if (count === void 0 || count === null) {\n    count = 1;\n  }\n  const features = [];\n  for (let i = 0; i < count; i++) {\n    features.push(point(randomPositionUnchecked(options.bbox)));\n  }\n  return featureCollection(features);\n}\nfunction randomPolygon(count) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  checkBBox(options.bbox);\n  if (count === void 0 || count === null) {\n    count = 1;\n  }\n  if (options.bbox === void 0 || options.bbox === null) {\n    options.bbox = [-180, -90, 180, 90];\n  }\n  if (!isNumber(options.num_vertices) || options.num_vertices === void 0) {\n    options.num_vertices = 10;\n  }\n  if (!isNumber(options.max_radial_length) || options.max_radial_length === void 0) {\n    options.max_radial_length = 10;\n  }\n  const bboxWidth = Math.abs(options.bbox[0] - options.bbox[2]);\n  const bboxHeight = Math.abs(options.bbox[1] - options.bbox[3]);\n  const maxRadius = Math.min(bboxWidth / 2, bboxHeight / 2);\n  if (options.max_radial_length > maxRadius) {\n    throw new Error(\"max_radial_length is greater than the radius of the bbox\");\n  }\n  const paddedBbox = [options.bbox[0] + options.max_radial_length, options.bbox[1] + options.max_radial_length, options.bbox[2] - options.max_radial_length, options.bbox[3] - options.max_radial_length];\n  const features = [];\n  for (let i = 0; i < count; i++) {\n    let vertices = [];\n    const circleOffsets = [...Array(options.num_vertices + 1)].map(Math.random);\n    circleOffsets.forEach((cur, index, arr) => {\n      arr[index] = index > 0 ? cur + arr[index - 1] : cur;\n    });\n    circleOffsets.forEach(cur => {\n      cur = cur * 2 * Math.PI / circleOffsets[circleOffsets.length - 1];\n      const radialScaler = Math.random();\n      vertices.push([radialScaler * (options.max_radial_length || 10) * Math.sin(cur), radialScaler * (options.max_radial_length || 10) * Math.cos(cur)]);\n    });\n    vertices[vertices.length - 1] = vertices[0];\n    vertices = vertices.reverse().map(vertexToCoordinate(randomPositionUnchecked(paddedBbox)));\n    features.push(polygon([vertices]));\n  }\n  return featureCollection(features);\n}\nfunction randomLineString(count) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  options = options || {};\n  if (!isObject(options)) {\n    throw new Error(\"options is invalid\");\n  }\n  const bbox = options.bbox;\n  checkBBox(bbox);\n  let num_vertices = options.num_vertices;\n  let max_length = options.max_length;\n  let max_rotation = options.max_rotation;\n  if (count === void 0 || count === null) {\n    count = 1;\n  }\n  if (!isNumber(num_vertices) || num_vertices === void 0 || num_vertices < 2) {\n    num_vertices = 10;\n  }\n  if (!isNumber(max_length) || max_length === void 0) {\n    max_length = 1e-4;\n  }\n  if (!isNumber(max_rotation) || max_rotation === void 0) {\n    max_rotation = Math.PI / 8;\n  }\n  const features = [];\n  for (let i = 0; i < count; i++) {\n    const startingPoint = randomPositionUnchecked(bbox);\n    const vertices = [startingPoint];\n    for (let j = 0; j < num_vertices - 1; j++) {\n      const priorAngle = j === 0 ? Math.random() * 2 * Math.PI : Math.tan((vertices[j][1] - vertices[j - 1][1]) / (vertices[j][0] - vertices[j - 1][0]));\n      const angle = priorAngle + (Math.random() - 0.5) * max_rotation * 2;\n      const distance = Math.random() * max_length;\n      vertices.push([vertices[j][0] + distance * Math.cos(angle), vertices[j][1] + distance * Math.sin(angle)]);\n    }\n    features.push(lineString(vertices));\n  }\n  return featureCollection(features);\n}\nfunction vertexToCoordinate(hub) {\n  return cur => {\n    return [cur[0] + hub[0], cur[1] + hub[1]];\n  };\n}\nfunction rnd() {\n  return Math.random() - 0.5;\n}\nfunction lon() {\n  return rnd() * 360;\n}\nfunction lat() {\n  return rnd() * 180;\n}\nfunction coordInBBox(bbox) {\n  return [Math.random() * (bbox[2] - bbox[0]) + bbox[0], Math.random() * (bbox[3] - bbox[1]) + bbox[1]];\n}\nexport { randomLineString, randomPoint, randomPolygon, randomPosition };","map":{"version":3,"names":["featureCollection","isNumber","isObject","lineString","point","polygon","validateBBox","randomPosition","bbox","checkBBox","randomPositionUnchecked","Array","isArray","coordInBBox","lon","lat","randomPoint","count","options","arguments","length","undefined","features","i","push","randomPolygon","num_vertices","max_radial_length","bboxWidth","Math","abs","bboxHeight","maxRadius","min","Error","paddedBbox","vertices","circleOffsets","map","random","forEach","cur","index","arr","PI","radialScaler","sin","cos","reverse","vertexToCoordinate","randomLineString","max_length","max_rotation","startingPoint","j","priorAngle","tan","angle","distance","hub","rnd"],"sources":["C:\\Users\\HP\\map-drawing-app\\node_modules\\@turf\\random\\index.ts"],"sourcesContent":["import {\n  BBox,\n  FeatureCollection,\n  LineString,\n  Point,\n  Polygon,\n  Position,\n} from \"geojson\";\nimport {\n  featureCollection,\n  isNumber,\n  isObject,\n  lineString,\n  point,\n  polygon,\n  validateBBox,\n} from \"@turf/helpers\";\n\n/**\n * Returns a random position within a {@link BBox|bounding box}.\n *\n * @function\n * @param {BBox} [bbox=[-180, -90, 180, 90]] a bounding box inside of which positions are placed.\n * @returns {Position} Position [longitude, latitude]\n * @throws {Error} if bbox is invalid\n * @example\n * var position = turf.randomPosition([-180, -90, 180, 90])\n * // => position\n */\nfunction randomPosition(bbox?: BBox | { bbox: BBox }): Position {\n  checkBBox(bbox);\n  return randomPositionUnchecked(bbox);\n}\n\n// does not check bbox for validity, that is handled by the exported functions\nfunction randomPositionUnchecked(bbox?: BBox | { bbox: BBox }): Position {\n  if (Array.isArray(bbox)) {\n    return coordInBBox(bbox);\n  }\n  if (bbox && bbox.bbox) {\n    return coordInBBox(bbox.bbox);\n  }\n  return [lon(), lat()];\n}\n\nfunction checkBBox(bbox?: BBox | { bbox: BBox }) {\n  if (bbox == null) {\n    return;\n  } else if (Array.isArray(bbox)) {\n    validateBBox(bbox);\n  } else if (bbox.bbox != null) {\n    validateBBox(bbox.bbox);\n  }\n}\n\n/**\n * Returns a random {@link point}.\n *\n * @function\n * @param {number} [count=1] how many geometries will be generated\n * @param {Object} [options={}] Optional parameters\n * @param {BBox} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.\n * @returns {FeatureCollection<Point>} GeoJSON FeatureCollection of points\n * @throws {Error} if bbox is invalid\n * @example\n * var points = turf.randomPoint(25, {bbox: [-180, -90, 180, 90]})\n * // => points\n */\nfunction randomPoint(\n  count?: number,\n  options: {\n    bbox?: BBox;\n  } = {}\n): FeatureCollection<Point, any> {\n  checkBBox(options.bbox);\n  if (count === undefined || count === null) {\n    count = 1;\n  }\n  const features = [];\n  for (let i = 0; i < count; i++) {\n    features.push(point(randomPositionUnchecked(options.bbox)));\n  }\n  return featureCollection(features);\n}\n\n/**\n * Returns a random {@link polygon}.\n *\n * @function\n * @param {number} [count=1] how many geometries will be generated\n * @param {Object} [options={}] Optional parameters\n * @param {BBox} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.\n * @param {number} [options.num_vertices=10] is how many coordinates each LineString will contain.\n * @param {number} [options.max_radial_length=10] is the maximum number of decimal degrees latitude or longitude that a\n * vertex can reach out of the center of the Polygon.\n * @returns {FeatureCollection<Polygon>} GeoJSON FeatureCollection of polygons\n * @throws {Error} if bbox is invalid\n * @example\n * var polygons = turf.randomPolygon(25, {bbox: [-180, -90, 180, 90]})\n * // => polygons\n */\nfunction randomPolygon(\n  count?: number,\n  options: {\n    bbox?: BBox;\n    num_vertices?: number;\n    max_radial_length?: number;\n  } = {}\n): FeatureCollection<Polygon, any> {\n  checkBBox(options.bbox);\n\n  // Default param\n  if (count === undefined || count === null) {\n    count = 1;\n  }\n  if (options.bbox === undefined || options.bbox === null) {\n    options.bbox = [-180, -90, 180, 90];\n  }\n  if (!isNumber(options.num_vertices) || options.num_vertices === undefined) {\n    options.num_vertices = 10;\n  }\n  if (\n    !isNumber(options.max_radial_length) ||\n    options.max_radial_length === undefined\n  ) {\n    options.max_radial_length = 10;\n  }\n\n  const bboxWidth = Math.abs(options.bbox[0] - options.bbox[2]);\n  const bboxHeight = Math.abs(options.bbox[1] - options.bbox[3]);\n\n  const maxRadius = Math.min(bboxWidth / 2, bboxHeight / 2);\n\n  if (options.max_radial_length > maxRadius) {\n    throw new Error(\"max_radial_length is greater than the radius of the bbox\");\n  }\n\n  // Create a padded bbox to avoid the polygons to be too close to the border\n  const paddedBbox = [\n    options.bbox[0] + options.max_radial_length,\n    options.bbox[1] + options.max_radial_length,\n    options.bbox[2] - options.max_radial_length,\n    options.bbox[3] - options.max_radial_length,\n  ] as BBox;\n\n  const features = [];\n  for (let i = 0; i < count; i++) {\n    let vertices: number[][] = [];\n    const circleOffsets = [...Array(options.num_vertices + 1)].map(Math.random);\n\n    // Sum Offsets\n    circleOffsets.forEach((cur, index, arr) => {\n      arr[index] = index > 0 ? cur + arr[index - 1] : cur;\n    });\n\n    // scaleOffsets\n    circleOffsets.forEach((cur) => {\n      cur = (cur * 2 * Math.PI) / circleOffsets[circleOffsets.length - 1];\n      const radialScaler = Math.random();\n      vertices.push([\n        radialScaler * (options.max_radial_length || 10) * Math.sin(cur),\n        radialScaler * (options.max_radial_length || 10) * Math.cos(cur),\n      ]);\n    });\n    vertices[vertices.length - 1] = vertices[0]; // close the ring\n\n    // center the polygon around something\n    vertices = vertices\n      .reverse() // Make counter-clockwise to adhere to right hand rule.\n      .map(vertexToCoordinate(randomPositionUnchecked(paddedBbox)));\n    features.push(polygon([vertices]));\n  }\n  return featureCollection(features);\n}\n\n/**\n * Returns a random {@link LineString}.\n *\n * @function\n * @param {number} [count=1] how many geometries will be generated\n * @param {Object} [options={}] Optional parameters\n * @param {BBox} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.\n * @param {number} [options.num_vertices=10] is how many coordinates each LineString will contain.\n * @param {number} [options.max_length=0.0001] is the maximum number of decimal degrees that a\n * vertex can be from its predecessor\n * @param {number} [options.max_rotation=Math.PI / 8] is the maximum number of radians that a\n * line segment can turn from the previous segment.\n * @returns {FeatureCollection<LineString>} GeoJSON FeatureCollection of linestrings\n * @throws {Error} if bbox is invalid\n * @example\n * var lineStrings = turf.randomLineString(25, {bbox: [-180, -90, 180, 90]})\n * // => lineStrings\n */\nfunction randomLineString(\n  count?: number,\n  options: {\n    bbox?: BBox;\n    num_vertices?: number;\n    max_length?: number;\n    max_rotation?: number;\n  } = {}\n): FeatureCollection<LineString, any> {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) {\n    throw new Error(\"options is invalid\");\n  }\n  const bbox = options.bbox;\n  checkBBox(bbox);\n  let num_vertices = options.num_vertices;\n  let max_length = options.max_length;\n  let max_rotation = options.max_rotation;\n  if (count === undefined || count === null) {\n    count = 1;\n  }\n\n  // Default parameters\n  if (\n    !isNumber(num_vertices) ||\n    num_vertices === undefined ||\n    num_vertices < 2\n  ) {\n    num_vertices = 10;\n  }\n  if (!isNumber(max_length) || max_length === undefined) {\n    max_length = 0.0001;\n  }\n  if (!isNumber(max_rotation) || max_rotation === undefined) {\n    max_rotation = Math.PI / 8;\n  }\n\n  const features = [];\n  for (let i = 0; i < count; i++) {\n    const startingPoint = randomPositionUnchecked(bbox);\n    const vertices = [startingPoint];\n    for (let j = 0; j < num_vertices - 1; j++) {\n      const priorAngle =\n        j === 0\n          ? Math.random() * 2 * Math.PI\n          : Math.tan(\n              (vertices[j][1] - vertices[j - 1][1]) /\n                (vertices[j][0] - vertices[j - 1][0])\n            );\n      const angle = priorAngle + (Math.random() - 0.5) * max_rotation * 2;\n      const distance = Math.random() * max_length;\n      vertices.push([\n        vertices[j][0] + distance * Math.cos(angle),\n        vertices[j][1] + distance * Math.sin(angle),\n      ]);\n    }\n    features.push(lineString(vertices));\n  }\n\n  return featureCollection(features);\n}\n\nfunction vertexToCoordinate(hub: number[]) {\n  return (cur: number[]) => {\n    return [cur[0] + hub[0], cur[1] + hub[1]];\n  };\n}\n\nfunction rnd() {\n  return Math.random() - 0.5;\n}\nfunction lon() {\n  return rnd() * 360;\n}\nfunction lat() {\n  return rnd() * 180;\n}\n\nfunction coordInBBox(bbox: BBox) {\n  return [\n    Math.random() * (bbox[2] - bbox[0]) + bbox[0],\n    Math.random() * (bbox[3] - bbox[1]) + bbox[1],\n  ];\n}\n\nexport { randomPosition, randomPoint, randomPolygon, randomLineString };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}