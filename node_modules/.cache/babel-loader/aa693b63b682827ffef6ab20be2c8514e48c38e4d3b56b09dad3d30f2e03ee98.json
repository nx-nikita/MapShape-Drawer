{"ast":null,"code":"// index.ts\nimport { geojsonRbush as rbush } from \"@turf/geojson-rbush\";\nimport { lineSegment } from \"@turf/line-segment\";\nimport { nearestPointOnLine } from \"@turf/nearest-point-on-line\";\nimport { booleanPointOnLine } from \"@turf/boolean-point-on-line\";\nimport { getCoords } from \"@turf/invariant\";\nimport { featureEach, segmentEach } from \"@turf/meta\";\nimport { featureCollection, isObject } from \"@turf/helpers\";\nimport equal from \"fast-deep-equal\";\nfunction lineOverlap(line1, line2) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var tolerance = options.tolerance || 0;\n  var features = [];\n  var tree = rbush();\n  const line = lineSegment(line1);\n  tree.load(line);\n  var overlapSegment;\n  let additionalSegments = [];\n  segmentEach(line2, function (segment) {\n    var doesOverlaps = false;\n    if (!segment) {\n      return;\n    }\n    featureEach(tree.search(segment), function (match) {\n      if (doesOverlaps === false) {\n        var coordsSegment = getCoords(segment).sort();\n        var coordsMatch = getCoords(match).sort();\n        if (equal(coordsSegment, coordsMatch)) {\n          doesOverlaps = true;\n          if (overlapSegment) {\n            overlapSegment = concatSegment(overlapSegment, segment) || overlapSegment;\n          } else overlapSegment = segment;\n        } else if (tolerance === 0 ? booleanPointOnLine(coordsSegment[0], match) && booleanPointOnLine(coordsSegment[1], match) : nearestPointOnLine(match, coordsSegment[0]).properties.dist <= tolerance && nearestPointOnLine(match, coordsSegment[1]).properties.dist <= tolerance) {\n          doesOverlaps = true;\n          if (overlapSegment) {\n            overlapSegment = concatSegment(overlapSegment, segment) || overlapSegment;\n          } else overlapSegment = segment;\n        } else if (tolerance === 0 ? booleanPointOnLine(coordsMatch[0], segment) && booleanPointOnLine(coordsMatch[1], segment) : nearestPointOnLine(segment, coordsMatch[0]).properties.dist <= tolerance && nearestPointOnLine(segment, coordsMatch[1]).properties.dist <= tolerance) {\n          if (overlapSegment) {\n            const combinedSegment = concatSegment(overlapSegment, match);\n            if (combinedSegment) {\n              overlapSegment = combinedSegment;\n            } else {\n              additionalSegments.push(match);\n            }\n          } else overlapSegment = match;\n        }\n      }\n    });\n    if (doesOverlaps === false && overlapSegment) {\n      features.push(overlapSegment);\n      if (additionalSegments.length) {\n        features = features.concat(additionalSegments);\n        additionalSegments = [];\n      }\n      overlapSegment = void 0;\n    }\n  });\n  if (overlapSegment) features.push(overlapSegment);\n  return featureCollection(features);\n}\nfunction concatSegment(line, segment) {\n  var coords = getCoords(segment);\n  var lineCoords = getCoords(line);\n  var start = lineCoords[0];\n  var end = lineCoords[lineCoords.length - 1];\n  var geom = line.geometry.coordinates;\n  if (equal(coords[0], start)) geom.unshift(coords[1]);else if (equal(coords[0], end)) geom.push(coords[1]);else if (equal(coords[1], start)) geom.unshift(coords[0]);else if (equal(coords[1], end)) geom.push(coords[0]);else return;\n  return line;\n}\nvar index_default = lineOverlap;\nexport { index_default as default, lineOverlap };","map":{"version":3,"names":["geojsonRbush","rbush","lineSegment","nearestPointOnLine","booleanPointOnLine","getCoords","featureEach","segmentEach","featureCollection","isObject","equal","lineOverlap","line1","line2","options","arguments","length","undefined","Error","tolerance","features","tree","line","load","overlapSegment","additionalSegments","segment","doesOverlaps","search","match","coordsSegment","sort","coordsMatch","concatSegment","properties","dist","combinedSegment","push","concat","coords","lineCoords","start","end","geom","geometry","coordinates","unshift","index_default"],"sources":["C:\\Users\\HP\\map-drawing-app\\node_modules\\@turf\\line-overlap\\index.ts"],"sourcesContent":["import { geojsonRbush as rbush } from \"@turf/geojson-rbush\";\nimport { lineSegment } from \"@turf/line-segment\";\nimport { nearestPointOnLine } from \"@turf/nearest-point-on-line\";\nimport { booleanPointOnLine } from \"@turf/boolean-point-on-line\";\nimport { getCoords } from \"@turf/invariant\";\nimport { featureEach, segmentEach } from \"@turf/meta\";\nimport {\n  FeatureCollection,\n  Feature,\n  LineString,\n  MultiLineString,\n  Polygon,\n  MultiPolygon,\n  GeoJsonProperties,\n} from \"geojson\";\nimport { featureCollection, isObject } from \"@turf/helpers\";\nimport equal from \"fast-deep-equal\";\n\n/**\n * Takes any LineString or Polygon and returns the overlapping lines between both features.\n *\n * @function\n * @param {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line1 any LineString or Polygon\n * @param {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line2 any LineString or Polygon\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.tolerance=0] Tolerance distance to match overlapping line segments (in kilometers)\n * @returns {FeatureCollection<LineString>} lines(s) that are overlapping between both features\n * @example\n * var line1 = turf.lineString([[115, -35], [125, -30], [135, -30], [145, -35]]);\n * var line2 = turf.lineString([[115, -25], [125, -30], [135, -30], [145, -25]]);\n *\n * var overlapping = turf.lineOverlap(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, overlapping]\n */\nfunction lineOverlap<\n  G1 extends LineString | MultiLineString | Polygon | MultiPolygon,\n  G2 extends LineString | MultiLineString | Polygon | MultiPolygon,\n>(\n  line1: Feature<G1> | G1,\n  line2: Feature<G2> | G2,\n  options: { tolerance?: number } = {}\n): FeatureCollection<LineString> {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var tolerance = options.tolerance || 0;\n\n  // Containers\n  var features: Feature<LineString, GeoJsonProperties>[] = [];\n\n  // Create Spatial Index\n  var tree = rbush<LineString>();\n\n  // To-Do -- HACK way to support typescript\n  const line: any = lineSegment(line1);\n  tree.load(line);\n  var overlapSegment: Feature<LineString> | undefined;\n  let additionalSegments: Feature<LineString>[] = [];\n\n  // Line Intersection\n\n  // Iterate over line segments\n  segmentEach(line2, function (segment) {\n    var doesOverlaps = false;\n\n    if (!segment) {\n      return;\n    }\n\n    // Iterate over each segments which falls within the same bounds\n    featureEach(tree.search(segment), function (match) {\n      if (doesOverlaps === false) {\n        var coordsSegment = getCoords(segment).sort();\n        var coordsMatch: any = getCoords(match).sort();\n\n        // Segment overlaps feature\n        if (equal(coordsSegment, coordsMatch)) {\n          doesOverlaps = true;\n          // Overlaps already exists - only append last coordinate of segment\n          if (overlapSegment) {\n            overlapSegment =\n              concatSegment(overlapSegment, segment) || overlapSegment;\n          } else overlapSegment = segment;\n          // Match segments which don't share nodes (Issue #901)\n        } else if (\n          tolerance === 0\n            ? booleanPointOnLine(coordsSegment[0], match) &&\n              booleanPointOnLine(coordsSegment[1], match)\n            : nearestPointOnLine(match, coordsSegment[0]).properties.dist! <=\n                tolerance &&\n              nearestPointOnLine(match, coordsSegment[1]).properties.dist! <=\n                tolerance\n        ) {\n          doesOverlaps = true;\n          if (overlapSegment) {\n            overlapSegment =\n              concatSegment(overlapSegment, segment) || overlapSegment;\n          } else overlapSegment = segment;\n        } else if (\n          tolerance === 0\n            ? booleanPointOnLine(coordsMatch[0], segment) &&\n              booleanPointOnLine(coordsMatch[1], segment)\n            : nearestPointOnLine(segment, coordsMatch[0]).properties.dist! <=\n                tolerance &&\n              nearestPointOnLine(segment, coordsMatch[1]).properties.dist! <=\n                tolerance\n        ) {\n          // Do not define (doesOverlap = true) since more matches can occur within the same segment\n          // doesOverlaps = true;\n          if (overlapSegment) {\n            const combinedSegment = concatSegment(overlapSegment, match);\n            if (combinedSegment) {\n              overlapSegment = combinedSegment;\n            } else {\n              additionalSegments.push(match);\n            }\n          } else overlapSegment = match;\n        }\n      }\n    });\n\n    // Segment doesn't overlap - add overlaps to results & reset\n    if (doesOverlaps === false && overlapSegment) {\n      features.push(overlapSegment);\n      if (additionalSegments.length) {\n        features = features.concat(additionalSegments);\n        additionalSegments = [];\n      }\n      overlapSegment = undefined;\n    }\n  });\n  // Add last segment if exists\n  if (overlapSegment) features.push(overlapSegment);\n\n  return featureCollection(features);\n}\n\n/**\n * Concat Segment\n *\n * @private\n * @param {Feature<LineString>} line LineString\n * @param {Feature<LineString>} segment 2-vertex LineString\n * @returns {Feature<LineString>} concat linestring\n */\nfunction concatSegment(\n  line: Feature<LineString>,\n  segment: Feature<LineString>\n) {\n  var coords = getCoords(segment);\n  var lineCoords = getCoords(line);\n  var start = lineCoords[0];\n  var end = lineCoords[lineCoords.length - 1];\n  var geom = line.geometry.coordinates;\n\n  if (equal(coords[0], start)) geom.unshift(coords[1]);\n  else if (equal(coords[0], end)) geom.push(coords[1]);\n  else if (equal(coords[1], start)) geom.unshift(coords[0]);\n  else if (equal(coords[1], end)) geom.push(coords[0]);\n  else return; // If the overlap leaves the segment unchanged, return undefined so that this can be identified.\n\n  // Otherwise return the mutated line.\n  return line;\n}\n\nexport { lineOverlap };\nexport default lineOverlap;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}