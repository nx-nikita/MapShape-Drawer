{"ast":null,"code":"// index.ts\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { pointToLineDistance } from \"@turf/point-to-line-distance\";\nimport { polygonToLine } from \"@turf/polygon-to-line\";\nimport { getGeom } from \"@turf/invariant\";\nimport { flattenEach } from \"@turf/meta\";\nimport { polygon } from \"@turf/helpers\";\nfunction pointToPolygonDistance(point, polygonOrMultiPolygon) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _a, _b;\n  const method = (_a = options.method) != null ? _a : \"geodesic\";\n  const units = (_b = options.units) != null ? _b : \"kilometers\";\n  if (!point) throw new Error(\"point is required\");\n  if (!polygonOrMultiPolygon) throw new Error(\"polygon or multi-polygon is required\");\n  const geom = getGeom(polygonOrMultiPolygon);\n  if (geom.type === \"MultiPolygon\") {\n    const distances = geom.coordinates.map(coords => pointToPolygonDistance(point, polygon(coords), {\n      method,\n      units\n    }));\n    return Math.min(...distances.map(Math.abs)) * (booleanPointInPolygon(point, polygonOrMultiPolygon) ? -1 : 1);\n  }\n  if (geom.coordinates.length > 1) {\n    const [exteriorDistance, ...interiorDistances] = geom.coordinates.map(coords => pointToPolygonDistance(point, polygon([coords]), {\n      method,\n      units\n    }));\n    if (exteriorDistance >= 0) return exteriorDistance;\n    const smallestInteriorDistance = Math.min(...interiorDistances);\n    if (smallestInteriorDistance < 0) return Math.abs(smallestInteriorDistance);\n    return Math.max(smallestInteriorDistance * -1, exteriorDistance);\n  }\n  const lines = polygonToLine(geom);\n  let minDistance = Infinity;\n  flattenEach(lines, feature => {\n    minDistance = Math.min(minDistance, pointToLineDistance(point, feature, {\n      method,\n      units\n    }));\n  });\n  return booleanPointInPolygon(point, geom) ? -minDistance : minDistance;\n}\nvar index_default = pointToPolygonDistance;\nexport { index_default as default, pointToPolygonDistance };","map":{"version":3,"names":["booleanPointInPolygon","pointToLineDistance","polygonToLine","getGeom","flattenEach","polygon","pointToPolygonDistance","point","polygonOrMultiPolygon","options","arguments","length","undefined","_a","_b","method","units","Error","geom","type","distances","coordinates","map","coords","Math","min","abs","exteriorDistance","interiorDistances","smallestInteriorDistance","max","lines","minDistance","Infinity","feature","index_default"],"sources":["C:\\Users\\HP\\map-drawing-app\\node_modules\\@turf\\point-to-polygon-distance\\index.ts"],"sourcesContent":["import { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport {\n  Feature,\n  Point,\n  Polygon,\n  MultiPolygon,\n  LineString,\n  Position,\n} from \"geojson\";\nimport { pointToLineDistance } from \"@turf/point-to-line-distance\";\nimport { polygonToLine } from \"@turf/polygon-to-line\";\nimport { getGeom } from \"@turf/invariant\";\nimport { flattenEach } from \"@turf/meta\";\nimport { polygon, Units } from \"@turf/helpers\";\n\n/**\n * Calculates the distance from a point to the edges of a polygon or multi-polygon.\n * Returns negative values for points inside the polygon.\n * Handles polygons with holes and multi-polygons.\n * A hole is treated as the exterior of the polygon.\n *\n * @param {Feature<Point> | Point | Position} point Input point\n * @param {Feature<Polygon | MultiPolygon> | Polygon | MultiPolygon} polygonOrMultiPolygon Input polygon or multipolygon\n * @param {Object} options Optional parameters\n * @param {Units} options.units Units of the result e.g. \"kilometers\", \"miles\", \"meters\"\n * @param {\"geodesic\" | \"planar\"} options.method Method of the result\n * @returns {number} Distance in meters (negative values for points inside the polygon)\n * @throws {Error} If input geometries are invalid\n */\nexport function pointToPolygonDistance(\n  point: Feature<Point> | Point | Position,\n  polygonOrMultiPolygon:\n    | Feature<Polygon | MultiPolygon>\n    | Polygon\n    | MultiPolygon,\n  options: {\n    units?: Units;\n    method?: \"geodesic\" | \"planar\";\n  } = {}\n): number {\n  const method = options.method ?? \"geodesic\";\n  const units = options.units ?? \"kilometers\";\n  // Input validation\n  if (!point) throw new Error(\"point is required\");\n  if (!polygonOrMultiPolygon)\n    throw new Error(\"polygon or multi-polygon is required\");\n\n  const geom = getGeom(polygonOrMultiPolygon);\n\n  if (geom.type === \"MultiPolygon\") {\n    const distances = geom.coordinates.map((coords) =>\n      pointToPolygonDistance(point, polygon(coords), { method, units })\n    );\n    return (\n      Math.min(...distances.map(Math.abs)) *\n      (booleanPointInPolygon(point, polygonOrMultiPolygon) ? -1 : 1)\n    );\n  }\n\n  if (geom.coordinates.length > 1) {\n    // Has holes\n    const [exteriorDistance, ...interiorDistances] = geom.coordinates.map(\n      (coords) =>\n        pointToPolygonDistance(point, polygon([coords]), { method, units })\n    );\n    if (exteriorDistance >= 0) return exteriorDistance;\n    // point is inside the exterior polygon shape\n    const smallestInteriorDistance = Math.min(...interiorDistances);\n    // point is inside one of the holes?\n    if (smallestInteriorDistance < 0) return Math.abs(smallestInteriorDistance);\n    // find which is closer, the distance to the hole or the distance to the edge of the exterior\n    // at this stage, exteriorDistance is negative and smallestInteriorDistance is positive\n    // but smallestInteriorDistance should be returned as negative\n    // and min of positive values <=> max of negative values\n    return Math.max(smallestInteriorDistance * -1, exteriorDistance);\n  }\n  // The actual distance operation - on a normal, hole-less polygon in meters\n  const lines = polygonToLine(geom);\n  let minDistance = Infinity;\n  flattenEach(lines, (feature) => {\n    minDistance = Math.min(\n      minDistance,\n      pointToLineDistance(point, feature as Feature<LineString>, {\n        method,\n        units,\n      })\n    );\n  });\n\n  return booleanPointInPolygon(point, geom) ? -minDistance : minDistance;\n}\n\nexport default pointToPolygonDistance;\n"],"mappings":";AAAA,SAASA,qBAAA,QAA6B;AAStC,SAASC,mBAAA,QAA2B;AACpC,SAASC,aAAA,QAAqB;AAC9B,SAASC,OAAA,QAAe;AACxB,SAASC,WAAA,QAAmB;AAC5B,SAASC,OAAA,QAAsB;AAgBxB,SAASC,uBACdC,KAAA,EACAC,qBAAA,EAQQ;EAAA,IAJRC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAGI,CAAC;EAtCP,IAAAG,EAAA,EAAAC,EAAA;EAwCE,MAAMC,MAAA,IAASF,EAAA,GAAAJ,OAAA,CAAQM,MAAA,KAAR,OAAAF,EAAA,GAAkB;EACjC,MAAMG,KAAA,IAAQF,EAAA,GAAAL,OAAA,CAAQO,KAAA,KAAR,OAAAF,EAAA,GAAiB;EAE/B,IAAI,CAACP,KAAA,EAAO,MAAM,IAAIU,KAAA,CAAM,mBAAmB;EAC/C,IAAI,CAACT,qBAAA,EACH,MAAM,IAAIS,KAAA,CAAM,sCAAsC;EAExD,MAAMC,IAAA,GAAOf,OAAA,CAAQK,qBAAqB;EAE1C,IAAIU,IAAA,CAAKC,IAAA,KAAS,gBAAgB;IAChC,MAAMC,SAAA,GAAYF,IAAA,CAAKG,WAAA,CAAYC,GAAA,CAAKC,MAAA,IACtCjB,sBAAA,CAAuBC,KAAA,EAAOF,OAAA,CAAQkB,MAAM,GAAG;MAAER,MAAA;MAAQC;IAAM,CAAC,CAClE;IACA,OACEQ,IAAA,CAAKC,GAAA,CAAI,GAAGL,SAAA,CAAUE,GAAA,CAAIE,IAAA,CAAKE,GAAG,CAAC,KAClC1B,qBAAA,CAAsBO,KAAA,EAAOC,qBAAqB,IAAI,KAAK;EAEhE;EAEA,IAAIU,IAAA,CAAKG,WAAA,CAAYV,MAAA,GAAS,GAAG;IAE/B,MAAM,CAACgB,gBAAA,EAAkB,GAAGC,iBAAiB,IAAIV,IAAA,CAAKG,WAAA,CAAYC,GAAA,CAC/DC,MAAA,IACCjB,sBAAA,CAAuBC,KAAA,EAAOF,OAAA,CAAQ,CAACkB,MAAM,CAAC,GAAG;MAAER,MAAA;MAAQC;IAAM,CAAC,CACtE;IACA,IAAIW,gBAAA,IAAoB,GAAG,OAAOA,gBAAA;IAElC,MAAME,wBAAA,GAA2BL,IAAA,CAAKC,GAAA,CAAI,GAAGG,iBAAiB;IAE9D,IAAIC,wBAAA,GAA2B,GAAG,OAAOL,IAAA,CAAKE,GAAA,CAAIG,wBAAwB;IAK1E,OAAOL,IAAA,CAAKM,GAAA,CAAID,wBAAA,GAA2B,IAAIF,gBAAgB;EACjE;EAEA,MAAMI,KAAA,GAAQ7B,aAAA,CAAcgB,IAAI;EAChC,IAAIc,WAAA,GAAcC,QAAA;EAClB7B,WAAA,CAAY2B,KAAA,EAAQG,OAAA,IAAY;IAC9BF,WAAA,GAAcR,IAAA,CAAKC,GAAA,CACjBO,WAAA,EACA/B,mBAAA,CAAoBM,KAAA,EAAO2B,OAAA,EAAgC;MACzDnB,MAAA;MACAC;IACF,CAAC,CACH;EACF,CAAC;EAED,OAAOhB,qBAAA,CAAsBO,KAAA,EAAOW,IAAI,IAAI,CAACc,WAAA,GAAcA,WAAA;AAC7D;AAEA,IAAOG,aAAA,GAAQ7B,sBAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}