{"ast":null,"code":"import * as turf from \"@turf/turf\";\nimport booleanContains from \"@turf/boolean-contains\";\nimport booleanIntersects from \"@turf/boolean-intersects\";\nexport const isFullyInside = (newPoly, existingPoly) => {\n  return turf.booleanContains(existingPoly, newPoly) || turf.booleanContains(newPoly, existingPoly);\n};\n/**\r\n * ✅ Check if a new polygon fully contains or is fully contained by existing polygons\r\n */\nexport const applyPolygonRules = (newFeature, existing) => {\n  for (const old of existing) {\n    if (!old.geometry) continue;\n\n    // Full containment → reject\n    if (booleanContains(newFeature, old) || booleanContains(old, newFeature)) {\n      return null;\n    }\n  }\n  return newFeature;\n};\n\n/**\r\n * ✅ Detect if new polygon overlaps any existing polygons\r\n */\nexport const hasOverlap = (newFeature, existingFeatures) => {\n  for (const f of existingFeatures) {\n    if (booleanIntersects(newFeature, f)) return true;\n  }\n  return false;\n};\n\n/**\r\n * ✅ Trim polygon safely\r\n * - Partial overlaps trimmed\r\n * - Ignore tiny slivers (<1 m²)\r\n * - Return null if fully overlapped\r\n */\nexport const trimPolygon = (newPoly, existingPoly) => {\n  try {\n    if (!newPoly.geometry || !existingPoly.geometry) return null;\n\n    // Step 1: Intersection check\n    const intersection = turf.intersect(newPoly, existingPoly);\n    if (!intersection) return newPoly; // No overlap\n\n    // Ignore tiny overlaps\n    if (turf.area(intersection) < 1) return newPoly;\n\n    // Step 2: Trim overlapping part\n    const trimmed = turf.difference(newPoly, existingPoly);\n    if (!trimmed) return null; // fully overlapped\n    if (turf.area(trimmed) < 1) return null; // tiny sliver\n\n    return trimmed;\n  } catch (err) {\n    console.warn(\"Auto-trim failed:\", err);\n    return null;\n  }\n};\n\n/**\r\n * ✅ Utility: Convert Circle or Rectangle to Polygon\r\n */\nexport const toPolygon = feature => {\n  var _feature$properties;\n  if (feature.geometry.type === \"Polygon\") return feature;\n  if ((_feature$properties = feature.properties) !== null && _feature$properties !== void 0 && _feature$properties.radius && feature.geometry.type === \"Point\") {\n    const [lng, lat] = feature.geometry.coordinates;\n    const polygon = turf.circle([lng, lat], feature.properties.radius, {\n      steps: 64,\n      units: \"meters\"\n    });\n    polygon.properties = {\n      ...feature.properties\n    };\n    return polygon;\n  }\n  if (feature.geometry.type === \"Polygon\" || feature.geometry.type === \"Rectangle\") {\n    return feature;\n  }\n  throw new Error(\"Unsupported feature type for polygon conversion\");\n};","map":{"version":3,"names":["turf","booleanContains","booleanIntersects","isFullyInside","newPoly","existingPoly","applyPolygonRules","newFeature","existing","old","geometry","hasOverlap","existingFeatures","f","trimPolygon","intersection","intersect","area","trimmed","difference","err","console","warn","toPolygon","feature","_feature$properties","type","properties","radius","lng","lat","coordinates","polygon","circle","steps","units","Error"],"sources":["C:/Users/HP/map-drawing-app/-Shapes-Drawer/src/utils/geometry.ts"],"sourcesContent":["import { Feature, Polygon } from \"geojson\";\r\nimport * as turf from \"@turf/turf\";\r\nimport booleanContains from \"@turf/boolean-contains\";\r\nimport booleanIntersects from \"@turf/boolean-intersects\";\r\n\r\n\r\nexport const isFullyInside = (\r\n  newPoly: Feature<Polygon>,\r\n  existingPoly: Feature<Polygon>\r\n): boolean => {\r\n  return (\r\n    turf.booleanContains(existingPoly as any, newPoly as any) ||\r\n    turf.booleanContains(newPoly as any, existingPoly as any)\r\n  );\r\n};\r\n/**\r\n * ✅ Check if a new polygon fully contains or is fully contained by existing polygons\r\n */\r\nexport const applyPolygonRules = (\r\n  newFeature: Feature<Polygon>,\r\n  existing: Feature<Polygon>[]\r\n): Feature<Polygon> | null => {\r\n  for (const old of existing) {\r\n    if (!old.geometry) continue;\r\n\r\n    // Full containment → reject\r\n    if (\r\n      booleanContains(newFeature as any, old as any) ||\r\n      booleanContains(old as any, newFeature as any)\r\n    ) {\r\n      return null;\r\n    }\r\n  }\r\n  return newFeature;\r\n};\r\n\r\n/**\r\n * ✅ Detect if new polygon overlaps any existing polygons\r\n */\r\nexport const hasOverlap = (\r\n  newFeature: Feature<Polygon>,\r\n  existingFeatures: Feature<Polygon>[]\r\n): boolean => {\r\n  for (const f of existingFeatures) {\r\n    if (booleanIntersects(newFeature as any, f as any)) return true;\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * ✅ Trim polygon safely\r\n * - Partial overlaps trimmed\r\n * - Ignore tiny slivers (<1 m²)\r\n * - Return null if fully overlapped\r\n */\r\nexport const trimPolygon = (\r\n  newPoly: Feature<Polygon>,\r\n  existingPoly: Feature<Polygon>\r\n): Feature<Polygon> | null => {\r\n  try {\r\n    if (!newPoly.geometry || !existingPoly.geometry) return null;\r\n\r\n    // Step 1: Intersection check\r\n    const intersection = (turf.intersect as any)(newPoly, existingPoly);\r\n\r\n    if (!intersection) return newPoly; // No overlap\r\n\r\n    // Ignore tiny overlaps\r\n    if ((turf.area as any)(intersection) < 1) return newPoly;\r\n\r\n    // Step 2: Trim overlapping part\r\n    const trimmed = (turf.difference as any)(newPoly, existingPoly) as Feature<Polygon> | null;\r\n\r\n    if (!trimmed) return null; // fully overlapped\r\n    if ((turf.area as any)(trimmed) < 1) return null; // tiny sliver\r\n\r\n    return trimmed;\r\n  } catch (err) {\r\n    console.warn(\"Auto-trim failed:\", err);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * ✅ Utility: Convert Circle or Rectangle to Polygon\r\n */\r\nexport const toPolygon = (feature: Feature<any>): Feature<Polygon> => {\r\n  if (feature.geometry.type === \"Polygon\") return feature as Feature<Polygon>;\r\n\r\n  if (feature.properties?.radius && feature.geometry.type === \"Point\") {\r\n    const [lng, lat] = feature.geometry.coordinates;\r\n    const polygon = (turf.circle as any)([lng, lat], feature.properties.radius, {\r\n      steps: 64,\r\n      units: \"meters\",\r\n    }) as Feature<Polygon>;\r\n    polygon.properties = { ...feature.properties };\r\n    return polygon;\r\n  }\r\n\r\n  if (feature.geometry.type === \"Polygon\" || feature.geometry.type === \"Rectangle\") {\r\n    return feature as Feature<Polygon>;\r\n  }\r\n\r\n  throw new Error(\"Unsupported feature type for polygon conversion\");\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}