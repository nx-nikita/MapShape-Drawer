{"ast":null,"code":"// index.ts\nimport { clone } from \"@turf/clone\";\nimport { booleanClockwise } from \"@turf/boolean-clockwise\";\nimport { geomEach, featureEach } from \"@turf/meta\";\nimport { getCoords } from \"@turf/invariant\";\nimport { featureCollection, isObject } from \"@turf/helpers\";\nfunction rewind(geojson) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _a, _b;\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  const mutate = (_a = options.mutate) != null ? _a : false;\n  const reverse = (_b = options.reverse) != null ? _b : false;\n  if (!geojson) throw new Error(\"<geojson> is required\");\n  if (typeof reverse !== \"boolean\") throw new Error(\"<reverse> must be a boolean\");\n  if (typeof mutate !== \"boolean\") throw new Error(\"<mutate> must be a boolean\");\n  if (!mutate && geojson.type !== \"Point\" && geojson.type !== \"MultiPoint\") {\n    geojson = clone(geojson);\n  }\n  const results = [];\n  switch (geojson.type) {\n    case \"GeometryCollection\":\n      geomEach(geojson, function (geometry) {\n        rewindFeature(geometry, reverse);\n      });\n      return geojson;\n    case \"FeatureCollection\":\n      featureEach(geojson, function (feature) {\n        const rewoundFeature = rewindFeature(feature, reverse);\n        featureEach(rewoundFeature, function (result) {\n          results.push(result);\n        });\n      });\n      return featureCollection(results);\n  }\n  return rewindFeature(geojson, reverse);\n}\nfunction rewindFeature(geojson, reverse) {\n  const type = geojson.type === \"Feature\" ? geojson.geometry.type : geojson.type;\n  switch (type) {\n    case \"GeometryCollection\":\n      geomEach(geojson, function (geometry) {\n        rewindFeature(geometry, reverse);\n      });\n      return geojson;\n    case \"LineString\":\n      rewindLineString(getCoords(geojson), reverse);\n      return geojson;\n    case \"Polygon\":\n      rewindPolygon(getCoords(geojson), reverse);\n      return geojson;\n    case \"MultiLineString\":\n      getCoords(geojson).forEach(function (lineCoords) {\n        rewindLineString(lineCoords, reverse);\n      });\n      return geojson;\n    case \"MultiPolygon\":\n      getCoords(geojson).forEach(function (lineCoords) {\n        rewindPolygon(lineCoords, reverse);\n      });\n      return geojson;\n    case \"Point\":\n    case \"MultiPoint\":\n      return geojson;\n  }\n}\nfunction rewindLineString(coords, reverse) {\n  if (booleanClockwise(coords) === reverse) coords.reverse();\n}\nfunction rewindPolygon(coords, reverse) {\n  if (booleanClockwise(coords[0]) !== reverse) {\n    coords[0].reverse();\n  }\n  for (let i = 1; i < coords.length; i++) {\n    if (booleanClockwise(coords[i]) === reverse) {\n      coords[i].reverse();\n    }\n  }\n}\nvar index_default = rewind;\nexport { index_default as default, rewind };","map":{"version":3,"names":["clone","booleanClockwise","geomEach","featureEach","getCoords","featureCollection","isObject","rewind","geojson","options","arguments","length","undefined","_a","_b","Error","mutate","reverse","type","results","geometry","rewindFeature","feature","rewoundFeature","result","push","rewindLineString","rewindPolygon","forEach","lineCoords","coords","i","index_default"],"sources":["C:\\Users\\HP\\map-drawing-app\\node_modules\\@turf\\rewind\\index.ts"],"sourcesContent":["import type {\n  Feature,\n  Position,\n  GeometryCollection,\n  Geometry,\n  LineString,\n  MultiLineString,\n  MultiPolygon,\n  Polygon,\n  FeatureCollection,\n} from \"geojson\";\nimport { clone } from \"@turf/clone\";\nimport { booleanClockwise } from \"@turf/boolean-clockwise\";\nimport { geomEach, featureEach } from \"@turf/meta\";\nimport { getCoords } from \"@turf/invariant\";\nimport { featureCollection, isObject } from \"@turf/helpers\";\nimport type { AllGeoJSON } from \"@turf/helpers\";\n\n/**\n * Rewind {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon} outer ring counterclockwise and inner rings clockwise (Uses {@link http://en.wikipedia.org/wiki/Shoelace_formula|Shoelace Formula}).\n *\n * @function\n * @param {GeoJSON} geojson input GeoJSON Polygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.reverse=false] enable reverse winding\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} rewind Polygon\n * @example\n * var polygon = turf.polygon([[[121, -29], [138, -29], [138, -18], [121, -18], [121, -29]]]);\n *\n * var rewind = turf.rewind(polygon);\n *\n * //addToMap\n * var addToMap = [rewind];\n */\nfunction rewind<T extends AllGeoJSON>(\n  geojson: T,\n  options: {\n    reverse?: boolean;\n    mutate?: boolean;\n  } = {}\n): Geometry | Feature | FeatureCollection {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  const mutate = options.mutate ?? false;\n  const reverse = options.reverse ?? false;\n\n  // validation\n  if (!geojson) throw new Error(\"<geojson> is required\");\n  if (typeof reverse !== \"boolean\")\n    throw new Error(\"<reverse> must be a boolean\");\n  if (typeof mutate !== \"boolean\")\n    throw new Error(\"<mutate> must be a boolean\");\n\n  // Prevent input mutation if requested and necessary.\n  if (!mutate && geojson.type !== \"Point\" && geojson.type !== \"MultiPoint\") {\n    geojson = clone(geojson);\n  }\n\n  // Support Feature Collection or Geometry Collection\n  const results: Feature[] = [];\n  switch (geojson.type) {\n    case \"GeometryCollection\":\n      geomEach(geojson, function (geometry) {\n        rewindFeature(geometry, reverse);\n      });\n      return geojson;\n    case \"FeatureCollection\":\n      featureEach(geojson, function (feature) {\n        const rewoundFeature = rewindFeature(feature, reverse) as Feature;\n        featureEach(rewoundFeature, function (result) {\n          results.push(result);\n        });\n      });\n      return featureCollection(results);\n  }\n  // Support Feature or Geometry Objects\n  return rewindFeature(geojson, reverse);\n}\n\n/**\n * Rewind\n *\n * @private\n * @param {Geometry|Feature<any>} geojson Geometry or Feature\n * @param {Boolean} [reverse=false] enable reverse winding\n * @returns {Geometry|Feature<any>} rewind Geometry or Feature\n */\nfunction rewindFeature(\n  geojson: Geometry | GeometryCollection | Feature,\n  reverse: boolean\n) {\n  const type =\n    geojson.type === \"Feature\" ? geojson.geometry.type : geojson.type;\n\n  // Support all GeoJSON Geometry Objects\n  switch (type) {\n    case \"GeometryCollection\":\n      geomEach(geojson, function (geometry) {\n        rewindFeature(geometry, reverse);\n      });\n      return geojson;\n    case \"LineString\":\n      rewindLineString(getCoords(geojson as LineString), reverse);\n      return geojson;\n    case \"Polygon\":\n      rewindPolygon(getCoords(geojson as Polygon), reverse);\n      return geojson;\n    case \"MultiLineString\":\n      getCoords(geojson as MultiLineString).forEach(function (lineCoords) {\n        rewindLineString(lineCoords, reverse);\n      });\n      return geojson;\n    case \"MultiPolygon\":\n      getCoords(geojson as MultiPolygon).forEach(function (lineCoords) {\n        rewindPolygon(lineCoords, reverse);\n      });\n      return geojson;\n    case \"Point\":\n    case \"MultiPoint\":\n      // noop\n      return geojson;\n  }\n}\n\n/**\n * Rewind LineString - outer ring clockwise\n *\n * @private\n * @param {Array<Array<number>>} coords GeoJSON LineString geometry coordinates\n * @param {Boolean} [reverse=false] enable reverse winding\n * @returns {void} mutates coordinates\n */\nfunction rewindLineString(coords: Position[], reverse: boolean) {\n  if (booleanClockwise(coords) === reverse) coords.reverse();\n}\n\n/**\n * Rewind Polygon - outer ring counterclockwise and inner rings clockwise.\n *\n * @private\n * @param {Array<Array<Array<number>>>} coords GeoJSON Polygon geometry coordinates\n * @param {Boolean} [reverse=false] enable reverse winding\n * @returns {void} mutates coordinates\n */\nfunction rewindPolygon(coords: Position[][], reverse: boolean) {\n  // outer ring\n  if (booleanClockwise(coords[0]) !== reverse) {\n    coords[0].reverse();\n  }\n  // inner rings\n  for (let i = 1; i < coords.length; i++) {\n    if (booleanClockwise(coords[i]) === reverse) {\n      coords[i].reverse();\n    }\n  }\n}\n\nexport { rewind };\nexport default rewind;\n"],"mappings":";AAWA,SAASA,KAAA,QAAa;AACtB,SAASC,gBAAA,QAAwB;AACjC,SAASC,QAAA,EAAUC,WAAA,QAAmB;AACtC,SAASC,SAAA,QAAiB;AAC1B,SAASC,iBAAA,EAAmBC,QAAA,QAAgB;AAoB5C,SAASC,OACPC,OAAA,EAKwC;EAAA,IAJxCC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAGI,CAAC;EAxCP,IAAAG,EAAA,EAAAC,EAAA;EA2CEL,OAAA,GAAUA,OAAA,IAAW,CAAC;EACtB,IAAI,CAACH,QAAA,CAASG,OAAO,GAAG,MAAM,IAAIM,KAAA,CAAM,oBAAoB;EAC5D,MAAMC,MAAA,IAASH,EAAA,GAAAJ,OAAA,CAAQO,MAAA,KAAR,OAAAH,EAAA,GAAkB;EACjC,MAAMI,OAAA,IAAUH,EAAA,GAAAL,OAAA,CAAQQ,OAAA,KAAR,OAAAH,EAAA,GAAmB;EAGnC,IAAI,CAACN,OAAA,EAAS,MAAM,IAAIO,KAAA,CAAM,uBAAuB;EACrD,IAAI,OAAOE,OAAA,KAAY,WACrB,MAAM,IAAIF,KAAA,CAAM,6BAA6B;EAC/C,IAAI,OAAOC,MAAA,KAAW,WACpB,MAAM,IAAID,KAAA,CAAM,4BAA4B;EAG9C,IAAI,CAACC,MAAA,IAAUR,OAAA,CAAQU,IAAA,KAAS,WAAWV,OAAA,CAAQU,IAAA,KAAS,cAAc;IACxEV,OAAA,GAAUR,KAAA,CAAMQ,OAAO;EACzB;EAGA,MAAMW,OAAA,GAAqB,EAAC;EAC5B,QAAQX,OAAA,CAAQU,IAAA;IACd,KAAK;MACHhB,QAAA,CAASM,OAAA,EAAS,UAAUY,QAAA,EAAU;QACpCC,aAAA,CAAcD,QAAA,EAAUH,OAAO;MACjC,CAAC;MACD,OAAOT,OAAA;IACT,KAAK;MACHL,WAAA,CAAYK,OAAA,EAAS,UAAUc,OAAA,EAAS;QACtC,MAAMC,cAAA,GAAiBF,aAAA,CAAcC,OAAA,EAASL,OAAO;QACrDd,WAAA,CAAYoB,cAAA,EAAgB,UAAUC,MAAA,EAAQ;UAC5CL,OAAA,CAAQM,IAAA,CAAKD,MAAM;QACrB,CAAC;MACH,CAAC;MACD,OAAOnB,iBAAA,CAAkBc,OAAO;EACpC;EAEA,OAAOE,aAAA,CAAcb,OAAA,EAASS,OAAO;AACvC;AAUA,SAASI,cACPb,OAAA,EACAS,OAAA,EACA;EACA,MAAMC,IAAA,GACJV,OAAA,CAAQU,IAAA,KAAS,YAAYV,OAAA,CAAQY,QAAA,CAASF,IAAA,GAAOV,OAAA,CAAQU,IAAA;EAG/D,QAAQA,IAAA;IACN,KAAK;MACHhB,QAAA,CAASM,OAAA,EAAS,UAAUY,QAAA,EAAU;QACpCC,aAAA,CAAcD,QAAA,EAAUH,OAAO;MACjC,CAAC;MACD,OAAOT,OAAA;IACT,KAAK;MACHkB,gBAAA,CAAiBtB,SAAA,CAAUI,OAAqB,GAAGS,OAAO;MAC1D,OAAOT,OAAA;IACT,KAAK;MACHmB,aAAA,CAAcvB,SAAA,CAAUI,OAAkB,GAAGS,OAAO;MACpD,OAAOT,OAAA;IACT,KAAK;MACHJ,SAAA,CAAUI,OAA0B,EAAEoB,OAAA,CAAQ,UAAUC,UAAA,EAAY;QAClEH,gBAAA,CAAiBG,UAAA,EAAYZ,OAAO;MACtC,CAAC;MACD,OAAOT,OAAA;IACT,KAAK;MACHJ,SAAA,CAAUI,OAAuB,EAAEoB,OAAA,CAAQ,UAAUC,UAAA,EAAY;QAC/DF,aAAA,CAAcE,UAAA,EAAYZ,OAAO;MACnC,CAAC;MACD,OAAOT,OAAA;IACT,KAAK;IACL,KAAK;MAEH,OAAOA,OAAA;EACX;AACF;AAUA,SAASkB,iBAAiBI,MAAA,EAAoBb,OAAA,EAAkB;EAC9D,IAAIhB,gBAAA,CAAiB6B,MAAM,MAAMb,OAAA,EAASa,MAAA,CAAOb,OAAA,CAAQ;AAC3D;AAUA,SAASU,cAAcG,MAAA,EAAsBb,OAAA,EAAkB;EAE7D,IAAIhB,gBAAA,CAAiB6B,MAAA,CAAO,CAAC,CAAC,MAAMb,OAAA,EAAS;IAC3Ca,MAAA,CAAO,CAAC,EAAEb,OAAA,CAAQ;EACpB;EAEA,SAASc,CAAA,GAAI,GAAGA,CAAA,GAAID,MAAA,CAAOnB,MAAA,EAAQoB,CAAA,IAAK;IACtC,IAAI9B,gBAAA,CAAiB6B,MAAA,CAAOC,CAAC,CAAC,MAAMd,OAAA,EAAS;MAC3Ca,MAAA,CAAOC,CAAC,EAAEd,OAAA,CAAQ;IACpB;EACF;AACF;AAGA,IAAOe,aAAA,GAAQzB,MAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}