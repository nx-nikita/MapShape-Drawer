{"ast":null,"code":"'use strict';\n\nvar RBush = require('rbush');\nvar Queue = require('tinyqueue');\nvar pointInPolygon = require('point-in-polygon');\nvar orient = require('robust-predicates/umd/orient2d.min.js').orient2d;\n\n// Fix for require issue in webpack https://github.com/mapbox/concaveman/issues/18\nif (Queue.default) {\n  Queue = Queue.default;\n}\nmodule.exports = concaveman;\nmodule.exports.default = concaveman;\nfunction concaveman(points, concavity, lengthThreshold) {\n  // a relative measure of concavity; higher value means simpler hull\n  concavity = Math.max(0, concavity === undefined ? 2 : concavity);\n\n  // when a segment goes below this length threshold, it won't be drilled down further\n  lengthThreshold = lengthThreshold || 0;\n\n  // start with a convex hull of the points\n  var hull = fastConvexHull(points);\n\n  // index the points with an R-tree\n  var tree = new RBush(16);\n  tree.toBBox = function (a) {\n    return {\n      minX: a[0],\n      minY: a[1],\n      maxX: a[0],\n      maxY: a[1]\n    };\n  };\n  tree.compareMinX = function (a, b) {\n    return a[0] - b[0];\n  };\n  tree.compareMinY = function (a, b) {\n    return a[1] - b[1];\n  };\n  tree.load(points);\n\n  // turn the convex hull into a linked list and populate the initial edge queue with the nodes\n  var queue = [];\n  for (var i = 0, last; i < hull.length; i++) {\n    var p = hull[i];\n    tree.remove(p);\n    last = insertNode(p, last);\n    queue.push(last);\n  }\n\n  // index the segments with an R-tree (for intersection checks)\n  var segTree = new RBush(16);\n  for (i = 0; i < queue.length; i++) segTree.insert(updateBBox(queue[i]));\n  var sqConcavity = concavity * concavity;\n  var sqLenThreshold = lengthThreshold * lengthThreshold;\n\n  // process edges one by one\n  while (queue.length) {\n    var node = queue.shift();\n    var a = node.p;\n    var b = node.next.p;\n\n    // skip the edge if it's already short enough\n    var sqLen = getSqDist(a, b);\n    if (sqLen < sqLenThreshold) continue;\n    var maxSqLen = sqLen / sqConcavity;\n\n    // find the best connection point for the current edge to flex inward to\n    p = findCandidate(tree, node.prev.p, a, b, node.next.next.p, maxSqLen, segTree);\n\n    // if we found a connection and it satisfies our concavity measure\n    if (p && Math.min(getSqDist(p, a), getSqDist(p, b)) <= maxSqLen) {\n      // connect the edge endpoints through this point and add 2 new edges to the queue\n      queue.push(node);\n      queue.push(insertNode(p, node));\n\n      // update point and segment indexes\n      tree.remove(p);\n      segTree.remove(node);\n      segTree.insert(updateBBox(node));\n      segTree.insert(updateBBox(node.next));\n    }\n  }\n\n  // convert the resulting hull linked list to an array of points\n  node = last;\n  var concave = [];\n  do {\n    concave.push(node.p);\n    node = node.next;\n  } while (node !== last);\n  concave.push(node.p);\n  return concave;\n}\nfunction findCandidate(tree, a, b, c, d, maxDist, segTree) {\n  var queue = new Queue([], compareDist);\n  var node = tree.data;\n\n  // search through the point R-tree with a depth-first search using a priority queue\n  // in the order of distance to the edge (b, c)\n  while (node) {\n    for (var i = 0; i < node.children.length; i++) {\n      var child = node.children[i];\n      var dist = node.leaf ? sqSegDist(child, b, c) : sqSegBoxDist(b, c, child);\n      if (dist > maxDist) continue; // skip the node if it's farther than we ever need\n\n      queue.push({\n        node: child,\n        dist: dist\n      });\n    }\n    while (queue.length && !queue.peek().node.children) {\n      var item = queue.pop();\n      var p = item.node;\n\n      // skip all points that are as close to adjacent edges (a,b) and (c,d),\n      // and points that would introduce self-intersections when connected\n      var d0 = sqSegDist(p, a, b);\n      var d1 = sqSegDist(p, c, d);\n      if (item.dist < d0 && item.dist < d1 && noIntersections(b, p, segTree) && noIntersections(c, p, segTree)) return p;\n    }\n    node = queue.pop();\n    if (node) node = node.node;\n  }\n  return null;\n}\nfunction compareDist(a, b) {\n  return a.dist - b.dist;\n}\n\n// square distance from a segment bounding box to the given one\nfunction sqSegBoxDist(a, b, bbox) {\n  if (inside(a, bbox) || inside(b, bbox)) return 0;\n  var d1 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.maxX, bbox.minY);\n  if (d1 === 0) return 0;\n  var d2 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.minX, bbox.maxY);\n  if (d2 === 0) return 0;\n  var d3 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY);\n  if (d3 === 0) return 0;\n  var d4 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY);\n  if (d4 === 0) return 0;\n  return Math.min(d1, d2, d3, d4);\n}\nfunction inside(a, bbox) {\n  return a[0] >= bbox.minX && a[0] <= bbox.maxX && a[1] >= bbox.minY && a[1] <= bbox.maxY;\n}\n\n// check if the edge (a,b) doesn't intersect any other edges\nfunction noIntersections(a, b, segTree) {\n  var minX = Math.min(a[0], b[0]);\n  var minY = Math.min(a[1], b[1]);\n  var maxX = Math.max(a[0], b[0]);\n  var maxY = Math.max(a[1], b[1]);\n  var edges = segTree.search({\n    minX: minX,\n    minY: minY,\n    maxX: maxX,\n    maxY: maxY\n  });\n  for (var i = 0; i < edges.length; i++) {\n    if (intersects(edges[i].p, edges[i].next.p, a, b)) return false;\n  }\n  return true;\n}\nfunction cross(p1, p2, p3) {\n  return orient(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);\n}\n\n// check if the edges (p1,q1) and (p2,q2) intersect\nfunction intersects(p1, q1, p2, q2) {\n  return p1 !== q2 && q1 !== p2 && cross(p1, q1, p2) > 0 !== cross(p1, q1, q2) > 0 && cross(p2, q2, p1) > 0 !== cross(p2, q2, q1) > 0;\n}\n\n// update the bounding box of a node's edge\nfunction updateBBox(node) {\n  var p1 = node.p;\n  var p2 = node.next.p;\n  node.minX = Math.min(p1[0], p2[0]);\n  node.minY = Math.min(p1[1], p2[1]);\n  node.maxX = Math.max(p1[0], p2[0]);\n  node.maxY = Math.max(p1[1], p2[1]);\n  return node;\n}\n\n// speed up convex hull by filtering out points inside quadrilateral formed by 4 extreme points\nfunction fastConvexHull(points) {\n  var left = points[0];\n  var top = points[0];\n  var right = points[0];\n  var bottom = points[0];\n\n  // find the leftmost, rightmost, topmost and bottommost points\n  for (var i = 0; i < points.length; i++) {\n    var p = points[i];\n    if (p[0] < left[0]) left = p;\n    if (p[0] > right[0]) right = p;\n    if (p[1] < top[1]) top = p;\n    if (p[1] > bottom[1]) bottom = p;\n  }\n\n  // filter out points that are inside the resulting quadrilateral\n  var cull = [left, top, right, bottom];\n  var filtered = cull.slice();\n  for (i = 0; i < points.length; i++) {\n    if (!pointInPolygon(points[i], cull)) filtered.push(points[i]);\n  }\n\n  // get convex hull around the filtered points\n  return convexHull(filtered);\n}\n\n// create a new node in a doubly linked list\nfunction insertNode(p, prev) {\n  var node = {\n    p: p,\n    prev: null,\n    next: null,\n    minX: 0,\n    minY: 0,\n    maxX: 0,\n    maxY: 0\n  };\n  if (!prev) {\n    node.prev = node;\n    node.next = node;\n  } else {\n    node.next = prev.next;\n    node.prev = prev;\n    prev.next.prev = node;\n    prev.next = node;\n  }\n  return node;\n}\n\n// square distance between 2 points\nfunction getSqDist(p1, p2) {\n  var dx = p1[0] - p2[0],\n    dy = p1[1] - p2[1];\n  return dx * dx + dy * dy;\n}\n\n// square distance from a point to a segment\nfunction sqSegDist(p, p1, p2) {\n  var x = p1[0],\n    y = p1[1],\n    dx = p2[0] - x,\n    dy = p2[1] - y;\n  if (dx !== 0 || dy !== 0) {\n    var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      x = p2[0];\n      y = p2[1];\n    } else if (t > 0) {\n      x += dx * t;\n      y += dy * t;\n    }\n  }\n  dx = p[0] - x;\n  dy = p[1] - y;\n  return dx * dx + dy * dy;\n}\n\n// segment to segment distance, ported from http://geomalgorithms.com/a07-_distance.html by Dan Sunday\nfunction sqSegSegDist(x0, y0, x1, y1, x2, y2, x3, y3) {\n  var ux = x1 - x0;\n  var uy = y1 - y0;\n  var vx = x3 - x2;\n  var vy = y3 - y2;\n  var wx = x0 - x2;\n  var wy = y0 - y2;\n  var a = ux * ux + uy * uy;\n  var b = ux * vx + uy * vy;\n  var c = vx * vx + vy * vy;\n  var d = ux * wx + uy * wy;\n  var e = vx * wx + vy * wy;\n  var D = a * c - b * b;\n  var sc, sN, tc, tN;\n  var sD = D;\n  var tD = D;\n  if (D === 0) {\n    sN = 0;\n    sD = 1;\n    tN = e;\n    tD = c;\n  } else {\n    sN = b * e - c * d;\n    tN = a * e - b * d;\n    if (sN < 0) {\n      sN = 0;\n      tN = e;\n      tD = c;\n    } else if (sN > sD) {\n      sN = sD;\n      tN = e + b;\n      tD = c;\n    }\n  }\n  if (tN < 0.0) {\n    tN = 0.0;\n    if (-d < 0.0) sN = 0.0;else if (-d > a) sN = sD;else {\n      sN = -d;\n      sD = a;\n    }\n  } else if (tN > tD) {\n    tN = tD;\n    if (-d + b < 0.0) sN = 0;else if (-d + b > a) sN = sD;else {\n      sN = -d + b;\n      sD = a;\n    }\n  }\n  sc = sN === 0 ? 0 : sN / sD;\n  tc = tN === 0 ? 0 : tN / tD;\n  var cx = (1 - sc) * x0 + sc * x1;\n  var cy = (1 - sc) * y0 + sc * y1;\n  var cx2 = (1 - tc) * x2 + tc * x3;\n  var cy2 = (1 - tc) * y2 + tc * y3;\n  var dx = cx2 - cx;\n  var dy = cy2 - cy;\n  return dx * dx + dy * dy;\n}\nfunction compareByX(a, b) {\n  return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];\n}\nfunction convexHull(points) {\n  points.sort(compareByX);\n  var lower = [];\n  for (var i = 0; i < points.length; i++) {\n    while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {\n      lower.pop();\n    }\n    lower.push(points[i]);\n  }\n  var upper = [];\n  for (var ii = points.length - 1; ii >= 0; ii--) {\n    while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[ii]) <= 0) {\n      upper.pop();\n    }\n    upper.push(points[ii]);\n  }\n  upper.pop();\n  lower.pop();\n  return lower.concat(upper);\n}","map":{"version":3,"names":["RBush","require","Queue","pointInPolygon","orient","orient2d","default","module","exports","concaveman","points","concavity","lengthThreshold","Math","max","undefined","hull","fastConvexHull","tree","toBBox","a","minX","minY","maxX","maxY","compareMinX","b","compareMinY","load","queue","i","last","length","p","remove","insertNode","push","segTree","insert","updateBBox","sqConcavity","sqLenThreshold","node","shift","next","sqLen","getSqDist","maxSqLen","findCandidate","prev","min","concave","c","d","maxDist","compareDist","data","children","child","dist","leaf","sqSegDist","sqSegBoxDist","peek","item","pop","d0","d1","noIntersections","bbox","inside","sqSegSegDist","d2","d3","d4","edges","search","intersects","cross","p1","p2","p3","q1","q2","left","top","right","bottom","cull","filtered","slice","convexHull","dx","dy","x","y","t","x0","y0","x1","y1","x2","y2","x3","y3","ux","uy","vx","vy","wx","wy","e","D","sc","sN","tc","tN","sD","tD","cx","cy","cx2","cy2","compareByX","sort","lower","upper","ii","concat"],"sources":["C:/Users/HP/map-drawing-app/-Shapes-Drawer/node_modules/concaveman/index.js"],"sourcesContent":["'use strict';\r\n\r\nvar RBush = require('rbush');\r\nvar Queue = require('tinyqueue');\r\nvar pointInPolygon = require('point-in-polygon');\r\nvar orient = require('robust-predicates/umd/orient2d.min.js').orient2d;\r\n\r\n// Fix for require issue in webpack https://github.com/mapbox/concaveman/issues/18\r\nif (Queue.default) {\r\n    Queue = Queue.default;\r\n}\r\n\r\nmodule.exports = concaveman;\r\nmodule.exports.default = concaveman;\r\n\r\nfunction concaveman(points, concavity, lengthThreshold) {\r\n    // a relative measure of concavity; higher value means simpler hull\r\n    concavity = Math.max(0, concavity === undefined ? 2 : concavity);\r\n\r\n    // when a segment goes below this length threshold, it won't be drilled down further\r\n    lengthThreshold = lengthThreshold || 0;\r\n\r\n    // start with a convex hull of the points\r\n    var hull = fastConvexHull(points);\r\n\r\n    // index the points with an R-tree\r\n    var tree = new RBush(16);\r\n    tree.toBBox = function (a) {\r\n        return {\r\n            minX: a[0],\r\n            minY: a[1],\r\n            maxX: a[0],\r\n            maxY: a[1]\r\n        };\r\n    };\r\n    tree.compareMinX = function (a, b) { return a[0] - b[0]; };\r\n    tree.compareMinY = function (a, b) { return a[1] - b[1]; };\r\n\r\n    tree.load(points);\r\n\r\n    // turn the convex hull into a linked list and populate the initial edge queue with the nodes\r\n    var queue = [];\r\n    for (var i = 0, last; i < hull.length; i++) {\r\n        var p = hull[i];\r\n        tree.remove(p);\r\n        last = insertNode(p, last);\r\n        queue.push(last);\r\n    }\r\n\r\n    // index the segments with an R-tree (for intersection checks)\r\n    var segTree = new RBush(16);\r\n    for (i = 0; i < queue.length; i++) segTree.insert(updateBBox(queue[i]));\r\n\r\n    var sqConcavity = concavity * concavity;\r\n    var sqLenThreshold = lengthThreshold * lengthThreshold;\r\n\r\n    // process edges one by one\r\n    while (queue.length) {\r\n        var node = queue.shift();\r\n        var a = node.p;\r\n        var b = node.next.p;\r\n\r\n        // skip the edge if it's already short enough\r\n        var sqLen = getSqDist(a, b);\r\n        if (sqLen < sqLenThreshold) continue;\r\n\r\n        var maxSqLen = sqLen / sqConcavity;\r\n\r\n        // find the best connection point for the current edge to flex inward to\r\n        p = findCandidate(tree, node.prev.p, a, b, node.next.next.p, maxSqLen, segTree);\r\n\r\n        // if we found a connection and it satisfies our concavity measure\r\n        if (p && Math.min(getSqDist(p, a), getSqDist(p, b)) <= maxSqLen) {\r\n            // connect the edge endpoints through this point and add 2 new edges to the queue\r\n            queue.push(node);\r\n            queue.push(insertNode(p, node));\r\n\r\n            // update point and segment indexes\r\n            tree.remove(p);\r\n            segTree.remove(node);\r\n            segTree.insert(updateBBox(node));\r\n            segTree.insert(updateBBox(node.next));\r\n        }\r\n    }\r\n\r\n    // convert the resulting hull linked list to an array of points\r\n    node = last;\r\n    var concave = [];\r\n    do {\r\n        concave.push(node.p);\r\n        node = node.next;\r\n    } while (node !== last);\r\n\r\n    concave.push(node.p);\r\n\r\n    return concave;\r\n}\r\n\r\nfunction findCandidate(tree, a, b, c, d, maxDist, segTree) {\r\n    var queue = new Queue([], compareDist);\r\n    var node = tree.data;\r\n\r\n    // search through the point R-tree with a depth-first search using a priority queue\r\n    // in the order of distance to the edge (b, c)\r\n    while (node) {\r\n        for (var i = 0; i < node.children.length; i++) {\r\n            var child = node.children[i];\r\n\r\n            var dist = node.leaf ? sqSegDist(child, b, c) : sqSegBoxDist(b, c, child);\r\n            if (dist > maxDist) continue; // skip the node if it's farther than we ever need\r\n\r\n            queue.push({\r\n                node: child,\r\n                dist: dist\r\n            });\r\n        }\r\n\r\n        while (queue.length && !queue.peek().node.children) {\r\n            var item = queue.pop();\r\n            var p = item.node;\r\n\r\n            // skip all points that are as close to adjacent edges (a,b) and (c,d),\r\n            // and points that would introduce self-intersections when connected\r\n            var d0 = sqSegDist(p, a, b);\r\n            var d1 = sqSegDist(p, c, d);\r\n            if (item.dist < d0 && item.dist < d1 &&\r\n                noIntersections(b, p, segTree) &&\r\n                noIntersections(c, p, segTree)) return p;\r\n        }\r\n\r\n        node = queue.pop();\r\n        if (node) node = node.node;\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nfunction compareDist(a, b) {\r\n    return a.dist - b.dist;\r\n}\r\n\r\n// square distance from a segment bounding box to the given one\r\nfunction sqSegBoxDist(a, b, bbox) {\r\n    if (inside(a, bbox) || inside(b, bbox)) return 0;\r\n    var d1 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.maxX, bbox.minY);\r\n    if (d1 === 0) return 0;\r\n    var d2 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.minX, bbox.maxY);\r\n    if (d2 === 0) return 0;\r\n    var d3 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY);\r\n    if (d3 === 0) return 0;\r\n    var d4 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY);\r\n    if (d4 === 0) return 0;\r\n    return Math.min(d1, d2, d3, d4);\r\n}\r\n\r\nfunction inside(a, bbox) {\r\n    return a[0] >= bbox.minX &&\r\n           a[0] <= bbox.maxX &&\r\n           a[1] >= bbox.minY &&\r\n           a[1] <= bbox.maxY;\r\n}\r\n\r\n// check if the edge (a,b) doesn't intersect any other edges\r\nfunction noIntersections(a, b, segTree) {\r\n    var minX = Math.min(a[0], b[0]);\r\n    var minY = Math.min(a[1], b[1]);\r\n    var maxX = Math.max(a[0], b[0]);\r\n    var maxY = Math.max(a[1], b[1]);\r\n\r\n    var edges = segTree.search({minX: minX, minY: minY, maxX: maxX, maxY: maxY});\r\n    for (var i = 0; i < edges.length; i++) {\r\n        if (intersects(edges[i].p, edges[i].next.p, a, b)) return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction cross(p1, p2, p3) {\r\n    return orient(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);\r\n}\r\n\r\n// check if the edges (p1,q1) and (p2,q2) intersect\r\nfunction intersects(p1, q1, p2, q2) {\r\n    return p1 !== q2 && q1 !== p2 &&\r\n        cross(p1, q1, p2) > 0 !== cross(p1, q1, q2) > 0 &&\r\n        cross(p2, q2, p1) > 0 !== cross(p2, q2, q1) > 0;\r\n}\r\n\r\n// update the bounding box of a node's edge\r\nfunction updateBBox(node) {\r\n    var p1 = node.p;\r\n    var p2 = node.next.p;\r\n    node.minX = Math.min(p1[0], p2[0]);\r\n    node.minY = Math.min(p1[1], p2[1]);\r\n    node.maxX = Math.max(p1[0], p2[0]);\r\n    node.maxY = Math.max(p1[1], p2[1]);\r\n    return node;\r\n}\r\n\r\n// speed up convex hull by filtering out points inside quadrilateral formed by 4 extreme points\r\nfunction fastConvexHull(points) {\r\n    var left = points[0];\r\n    var top = points[0];\r\n    var right = points[0];\r\n    var bottom = points[0];\r\n\r\n    // find the leftmost, rightmost, topmost and bottommost points\r\n    for (var i = 0; i < points.length; i++) {\r\n        var p = points[i];\r\n        if (p[0] < left[0]) left = p;\r\n        if (p[0] > right[0]) right = p;\r\n        if (p[1] < top[1]) top = p;\r\n        if (p[1] > bottom[1]) bottom = p;\r\n    }\r\n\r\n    // filter out points that are inside the resulting quadrilateral\r\n    var cull = [left, top, right, bottom];\r\n    var filtered = cull.slice();\r\n    for (i = 0; i < points.length; i++) {\r\n        if (!pointInPolygon(points[i], cull)) filtered.push(points[i]);\r\n    }\r\n\r\n    // get convex hull around the filtered points\r\n    return convexHull(filtered);\r\n}\r\n\r\n// create a new node in a doubly linked list\r\nfunction insertNode(p, prev) {\r\n    var node = {\r\n        p: p,\r\n        prev: null,\r\n        next: null,\r\n        minX: 0,\r\n        minY: 0,\r\n        maxX: 0,\r\n        maxY: 0\r\n    };\r\n\r\n    if (!prev) {\r\n        node.prev = node;\r\n        node.next = node;\r\n\r\n    } else {\r\n        node.next = prev.next;\r\n        node.prev = prev;\r\n        prev.next.prev = node;\r\n        prev.next = node;\r\n    }\r\n    return node;\r\n}\r\n\r\n// square distance between 2 points\r\nfunction getSqDist(p1, p2) {\r\n\r\n    var dx = p1[0] - p2[0],\r\n        dy = p1[1] - p2[1];\r\n\r\n    return dx * dx + dy * dy;\r\n}\r\n\r\n// square distance from a point to a segment\r\nfunction sqSegDist(p, p1, p2) {\r\n\r\n    var x = p1[0],\r\n        y = p1[1],\r\n        dx = p2[0] - x,\r\n        dy = p2[1] - y;\r\n\r\n    if (dx !== 0 || dy !== 0) {\r\n\r\n        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\r\n\r\n        if (t > 1) {\r\n            x = p2[0];\r\n            y = p2[1];\r\n\r\n        } else if (t > 0) {\r\n            x += dx * t;\r\n            y += dy * t;\r\n        }\r\n    }\r\n\r\n    dx = p[0] - x;\r\n    dy = p[1] - y;\r\n\r\n    return dx * dx + dy * dy;\r\n}\r\n\r\n// segment to segment distance, ported from http://geomalgorithms.com/a07-_distance.html by Dan Sunday\r\nfunction sqSegSegDist(x0, y0, x1, y1, x2, y2, x3, y3) {\r\n    var ux = x1 - x0;\r\n    var uy = y1 - y0;\r\n    var vx = x3 - x2;\r\n    var vy = y3 - y2;\r\n    var wx = x0 - x2;\r\n    var wy = y0 - y2;\r\n    var a = ux * ux + uy * uy;\r\n    var b = ux * vx + uy * vy;\r\n    var c = vx * vx + vy * vy;\r\n    var d = ux * wx + uy * wy;\r\n    var e = vx * wx + vy * wy;\r\n    var D = a * c - b * b;\r\n\r\n    var sc, sN, tc, tN;\r\n    var sD = D;\r\n    var tD = D;\r\n\r\n    if (D === 0) {\r\n        sN = 0;\r\n        sD = 1;\r\n        tN = e;\r\n        tD = c;\r\n    } else {\r\n        sN = b * e - c * d;\r\n        tN = a * e - b * d;\r\n        if (sN < 0) {\r\n            sN = 0;\r\n            tN = e;\r\n            tD = c;\r\n        } else if (sN > sD) {\r\n            sN = sD;\r\n            tN = e + b;\r\n            tD = c;\r\n        }\r\n    }\r\n\r\n    if (tN < 0.0) {\r\n        tN = 0.0;\r\n        if (-d < 0.0) sN = 0.0;\r\n        else if (-d > a) sN = sD;\r\n        else {\r\n            sN = -d;\r\n            sD = a;\r\n        }\r\n    } else if (tN > tD) {\r\n        tN = tD;\r\n        if ((-d + b) < 0.0) sN = 0;\r\n        else if (-d + b > a) sN = sD;\r\n        else {\r\n            sN = -d + b;\r\n            sD = a;\r\n        }\r\n    }\r\n\r\n    sc = sN === 0 ? 0 : sN / sD;\r\n    tc = tN === 0 ? 0 : tN / tD;\r\n\r\n    var cx = (1 - sc) * x0 + sc * x1;\r\n    var cy = (1 - sc) * y0 + sc * y1;\r\n    var cx2 = (1 - tc) * x2 + tc * x3;\r\n    var cy2 = (1 - tc) * y2 + tc * y3;\r\n    var dx = cx2 - cx;\r\n    var dy = cy2 - cy;\r\n\r\n    return dx * dx + dy * dy;\r\n}\r\n\r\nfunction compareByX(a, b) {\r\n    return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];\r\n}\r\n\r\nfunction convexHull(points) {\r\n    points.sort(compareByX);\r\n\r\n    var lower = [];\r\n    for (var i = 0; i < points.length; i++) {\r\n        while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {\r\n            lower.pop();\r\n        }\r\n        lower.push(points[i]);\r\n    }\r\n\r\n    var upper = [];\r\n    for (var ii = points.length - 1; ii >= 0; ii--) {\r\n        while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[ii]) <= 0) {\r\n            upper.pop();\r\n        }\r\n        upper.push(points[ii]);\r\n    }\r\n\r\n    upper.pop();\r\n    lower.pop();\r\n    return lower.concat(upper);\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}