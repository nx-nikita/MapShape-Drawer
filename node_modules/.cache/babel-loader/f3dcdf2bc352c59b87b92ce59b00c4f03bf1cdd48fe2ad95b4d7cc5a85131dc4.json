{"ast":null,"code":"// index.ts\nimport { circle } from \"@turf/circle\";\nimport { lineArc } from \"@turf/line-arc\";\nimport { coordEach } from \"@turf/meta\";\nimport { isObject, polygon } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\nfunction sector(center, radius, bearing1, bearing2) {\n  let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  const properties = options.properties;\n  if (!center) throw new Error(\"center is required\");\n  if (bearing1 === void 0 || bearing1 === null) throw new Error(\"bearing1 is required\");\n  if (bearing2 === void 0 || bearing2 === null) throw new Error(\"bearing2 is required\");\n  if (!radius) throw new Error(\"radius is required\");\n  if (typeof options !== \"object\") throw new Error(\"options must be an object\");\n  if (convertAngleTo360(bearing1) === convertAngleTo360(bearing2)) {\n    return circle(center, radius, options);\n  }\n  const coords = getCoords(center);\n  const arc = lineArc(center, radius, bearing1, bearing2, options);\n  const sliceCoords = [[coords]];\n  coordEach(arc, function (currentCoords) {\n    sliceCoords[0].push(currentCoords);\n  });\n  sliceCoords[0].push(coords);\n  return polygon(sliceCoords, properties);\n}\nfunction convertAngleTo360(alpha) {\n  let beta = alpha % 360;\n  if (beta < 0) {\n    beta += 360;\n  }\n  return beta;\n}\nvar index_default = sector;\nexport { index_default as default, sector };","map":{"version":3,"names":["circle","lineArc","coordEach","isObject","polygon","getCoords","sector","center","radius","bearing1","bearing2","options","arguments","length","undefined","Error","properties","convertAngleTo360","coords","arc","sliceCoords","currentCoords","push","alpha","beta","index_default"],"sources":["C:\\Users\\HP\\map-drawing-app\\node_modules\\@turf\\sector\\index.ts"],"sourcesContent":["import { Feature, Polygon, GeoJsonProperties } from \"geojson\";\nimport { circle } from \"@turf/circle\";\nimport { lineArc } from \"@turf/line-arc\";\nimport { coordEach } from \"@turf/meta\";\nimport { Units, Coord, isObject, polygon } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\n\n/**\n * Creates a circular sector of a circle of given radius and center {@link Point},\n * between (clockwise) bearing1 and bearing2; 0 bearing is North of center point, positive clockwise.\n *\n * @function\n * @param {Coord} center center point\n * @param {number} radius radius of the circle\n * @param {number} bearing1 angle, in decimal degrees, of the first radius of the sector\n * @param {number} bearing2 angle, in decimal degrees, of the second radius of the sector\n * @param {Object} [options={}] Optional parameters\n * @param {Units} [options.units='kilometers'] Supports all valid Turf {@link https://turfjs.org/docs/api/types/Units Units}\n * @param {number} [options.steps=64] number of steps\n * @param {Properties} [options.properties={}] Translate properties to Feature Polygon\n * @returns {Feature<Polygon>} sector polygon\n * @example\n * var center = turf.point([-75, 40]);\n * var radius = 5;\n * var bearing1 = 25;\n * var bearing2 = 45;\n *\n * var sector = turf.sector(center, radius, bearing1, bearing2);\n *\n * //addToMap\n * var addToMap = [center, sector];\n */\nfunction sector(\n  center: Coord,\n  radius: number,\n  bearing1: number,\n  bearing2: number,\n  options: {\n    steps?: number;\n    units?: Units;\n    properties?: GeoJsonProperties;\n  } = {}\n): Feature<Polygon> {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  // Most options only for passing through to circle()\n  const properties = options.properties;\n\n  // validation\n  if (!center) throw new Error(\"center is required\");\n  if (bearing1 === undefined || bearing1 === null)\n    throw new Error(\"bearing1 is required\");\n  if (bearing2 === undefined || bearing2 === null)\n    throw new Error(\"bearing2 is required\");\n  if (!radius) throw new Error(\"radius is required\");\n  if (typeof options !== \"object\") throw new Error(\"options must be an object\");\n\n  if (convertAngleTo360(bearing1) === convertAngleTo360(bearing2)) {\n    return circle(center, radius, options);\n  }\n  const coords = getCoords(center);\n  const arc = lineArc(center, radius, bearing1, bearing2, options);\n  const sliceCoords = [[coords]];\n  coordEach(arc, function (currentCoords) {\n    sliceCoords[0].push(currentCoords);\n  });\n  sliceCoords[0].push(coords);\n\n  return polygon(sliceCoords, properties);\n}\n\n/**\n * Takes any angle in degrees\n * and returns a valid angle between 0-360 degrees\n *\n * @private\n * @param {number} alpha angle between -180-180 degrees\n * @returns {number} angle between 0-360 degrees\n */\nfunction convertAngleTo360(alpha: number) {\n  let beta = alpha % 360;\n  if (beta < 0) {\n    beta += 360;\n  }\n  return beta;\n}\n\nexport { sector };\nexport default sector;\n"],"mappings":";AACA,SAASA,MAAA,QAAc;AACvB,SAASC,OAAA,QAAe;AACxB,SAASC,SAAA,QAAiB;AAC1B,SAAuBC,QAAA,EAAUC,OAAA,QAAe;AAChD,SAASC,SAAA,QAAiB;AA2B1B,SAASC,OACPC,MAAA,EACAC,MAAA,EACAC,QAAA,EACAC,QAAA,EAMkB;EAAA,IALlBC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAII,CAAC;EAGLD,OAAA,GAAUA,OAAA,IAAW,CAAC;EACtB,IAAI,CAACR,QAAA,CAASQ,OAAO,GAAG,MAAM,IAAII,KAAA,CAAM,oBAAoB;EAE5D,MAAMC,UAAA,GAAaL,OAAA,CAAQK,UAAA;EAG3B,IAAI,CAACT,MAAA,EAAQ,MAAM,IAAIQ,KAAA,CAAM,oBAAoB;EACjD,IAAIN,QAAA,KAAa,UAAaA,QAAA,KAAa,MACzC,MAAM,IAAIM,KAAA,CAAM,sBAAsB;EACxC,IAAIL,QAAA,KAAa,UAAaA,QAAA,KAAa,MACzC,MAAM,IAAIK,KAAA,CAAM,sBAAsB;EACxC,IAAI,CAACP,MAAA,EAAQ,MAAM,IAAIO,KAAA,CAAM,oBAAoB;EACjD,IAAI,OAAOJ,OAAA,KAAY,UAAU,MAAM,IAAII,KAAA,CAAM,2BAA2B;EAE5E,IAAIE,iBAAA,CAAkBR,QAAQ,MAAMQ,iBAAA,CAAkBP,QAAQ,GAAG;IAC/D,OAAOV,MAAA,CAAOO,MAAA,EAAQC,MAAA,EAAQG,OAAO;EACvC;EACA,MAAMO,MAAA,GAASb,SAAA,CAAUE,MAAM;EAC/B,MAAMY,GAAA,GAAMlB,OAAA,CAAQM,MAAA,EAAQC,MAAA,EAAQC,QAAA,EAAUC,QAAA,EAAUC,OAAO;EAC/D,MAAMS,WAAA,GAAc,CAAC,CAACF,MAAM,CAAC;EAC7BhB,SAAA,CAAUiB,GAAA,EAAK,UAAUE,aAAA,EAAe;IACtCD,WAAA,CAAY,CAAC,EAAEE,IAAA,CAAKD,aAAa;EACnC,CAAC;EACDD,WAAA,CAAY,CAAC,EAAEE,IAAA,CAAKJ,MAAM;EAE1B,OAAOd,OAAA,CAAQgB,WAAA,EAAaJ,UAAU;AACxC;AAUA,SAASC,kBAAkBM,KAAA,EAAe;EACxC,IAAIC,IAAA,GAAOD,KAAA,GAAQ;EACnB,IAAIC,IAAA,GAAO,GAAG;IACZA,IAAA,IAAQ;EACV;EACA,OAAOA,IAAA;AACT;AAGA,IAAOC,aAAA,GAAQnB,MAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}