{"ast":null,"code":"// index.ts\nimport { booleanIntersects as intersect } from \"@turf/boolean-intersects\";\nimport { convertLength, featureCollection, polygon } from \"@turf/helpers\";\nfunction rectangleGrid(bbox, cellWidth, cellHeight) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const results = [];\n  const west = bbox[0];\n  const south = bbox[1];\n  const east = bbox[2];\n  const north = bbox[3];\n  const bboxWidth = east - west;\n  const cellWidthDeg = convertLength(cellWidth, options.units, \"degrees\");\n  const bboxHeight = north - south;\n  const cellHeightDeg = convertLength(cellHeight, options.units, \"degrees\");\n  const columns = Math.floor(Math.abs(bboxWidth) / cellWidthDeg);\n  const rows = Math.floor(Math.abs(bboxHeight) / cellHeightDeg);\n  const deltaX = (bboxWidth - columns * cellWidthDeg) / 2;\n  const deltaY = (bboxHeight - rows * cellHeightDeg) / 2;\n  let currentX = west + deltaX;\n  for (let column = 0; column < columns; column++) {\n    let currentY = south + deltaY;\n    for (let row = 0; row < rows; row++) {\n      const cellPoly = polygon([[[currentX, currentY], [currentX, currentY + cellHeightDeg], [currentX + cellWidthDeg, currentY + cellHeightDeg], [currentX + cellWidthDeg, currentY], [currentX, currentY]]], options.properties);\n      if (options.mask) {\n        if (intersect(options.mask, cellPoly)) {\n          results.push(cellPoly);\n        }\n      } else {\n        results.push(cellPoly);\n      }\n      currentY += cellHeightDeg;\n    }\n    currentX += cellWidthDeg;\n  }\n  return featureCollection(results);\n}\nvar index_default = rectangleGrid;\nexport { index_default as default, rectangleGrid };","map":{"version":3,"names":["booleanIntersects","intersect","convertLength","featureCollection","polygon","rectangleGrid","bbox","cellWidth","cellHeight","options","arguments","length","undefined","results","west","south","east","north","bboxWidth","cellWidthDeg","units","bboxHeight","cellHeightDeg","columns","Math","floor","abs","rows","deltaX","deltaY","currentX","column","currentY","row","cellPoly","properties","mask","push","index_default"],"sources":["C:\\Users\\HP\\map-drawing-app\\node_modules\\@turf\\rectangle-grid\\index.ts"],"sourcesContent":["import { booleanIntersects as intersect } from \"@turf/boolean-intersects\";\nimport {\n  BBox,\n  Feature,\n  FeatureCollection,\n  MultiPolygon,\n  Polygon,\n  GeoJsonProperties,\n} from \"geojson\";\nimport {\n  convertLength,\n  featureCollection,\n  polygon,\n  Units,\n} from \"@turf/helpers\";\n/**\n * Creates a grid of rectangular polygons with width and height consistent in degrees\n *\n * @function\n * @param {BBox} bbox extent of grid in [minX, minY, maxX, maxY] order.  If the grid does not fill the bbox perfectly, it is centered.\n * @param {number} cellWidth width of each cell, in units\n * @param {number} cellHeight height of each cell, in units\n * @param {Object} [options={}] Optional parameters\n * @param {Units} [options.units='kilometers'] the units of the cell width and height value.\n * Supports all valid Turf {@link https://github.com/Turfjs/turf/blob/master/packages/turf-helpers/README_UNITS.md Units}.\n * If you are looking for rectangles with equal width and height in linear units (e.g. kilometers) this is not the module for you.\n * The cellWidth and cellHeight is converted from units provided to degrees internally, so the width and height of resulting polygons will be consistent only in degrees.\n * @param {Feature<Polygon|MultiPolygon>} [options.mask] if passed a Polygon or MultiPolygon,\n * the grid Points will be created only inside it\n * @param {Object} [options.properties={}] passed to each point of the grid\n * @returns {FeatureCollection<Polygon>} a grid of polygons\n * @example\n * var bbox = [-95, 30 ,-85, 40];\n * var cellWidth = 50;\n * var cellHeight = 20;\n * var options = {units: 'miles'};\n *\n * var rectangleGrid = turf.rectangleGrid(bbox, cellWidth, cellHeight, options);\n *\n * //addToMap\n * var addToMap = [rectangleGrid]\n */\nfunction rectangleGrid<P extends GeoJsonProperties = GeoJsonProperties>(\n  bbox: BBox,\n  cellWidth: number,\n  cellHeight: number,\n  options: {\n    units?: Units;\n    properties?: P;\n    mask?: Feature<Polygon | MultiPolygon> | Polygon | MultiPolygon;\n  } = {}\n): FeatureCollection<Polygon, P> {\n  // Containers\n  const results = [];\n  const west = bbox[0];\n  const south = bbox[1];\n  const east = bbox[2];\n  const north = bbox[3];\n\n  const bboxWidth = east - west;\n  const cellWidthDeg = convertLength(cellWidth, options.units, \"degrees\");\n\n  const bboxHeight = north - south;\n  const cellHeightDeg = convertLength(cellHeight, options.units, \"degrees\");\n\n  const columns = Math.floor(Math.abs(bboxWidth) / cellWidthDeg);\n  const rows = Math.floor(Math.abs(bboxHeight) / cellHeightDeg);\n\n  // if the grid does not fill the bbox perfectly, center it.\n  const deltaX = (bboxWidth - columns * cellWidthDeg) / 2;\n  const deltaY = (bboxHeight - rows * cellHeightDeg) / 2;\n\n  // iterate over columns & rows\n  let currentX = west + deltaX;\n  for (let column = 0; column < columns; column++) {\n    let currentY = south + deltaY;\n    for (let row = 0; row < rows; row++) {\n      const cellPoly = polygon(\n        [\n          [\n            [currentX, currentY],\n            [currentX, currentY + cellHeightDeg],\n            [currentX + cellWidthDeg, currentY + cellHeightDeg],\n            [currentX + cellWidthDeg, currentY],\n            [currentX, currentY],\n          ],\n        ],\n        options.properties\n      );\n      if (options.mask) {\n        if (intersect(options.mask, cellPoly)) {\n          results.push(cellPoly);\n        }\n      } else {\n        results.push(cellPoly);\n      }\n\n      currentY += cellHeightDeg;\n    }\n    currentX += cellWidthDeg;\n  }\n  return featureCollection(results);\n}\n\nexport { rectangleGrid };\nexport default rectangleGrid;\n"],"mappings":";AAAA,SAASA,iBAAA,IAAqBC,SAAA,QAAiB;AAS/C,SACEC,aAAA,EACAC,iBAAA,EACAC,OAAA,QAEK;AA4BP,SAASC,cACPC,IAAA,EACAC,SAAA,EACAC,UAAA,EAM+B;EAAA,IAL/BC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAII,CAAC;EAGL,MAAMG,OAAA,GAAU,EAAC;EACjB,MAAMC,IAAA,GAAOR,IAAA,CAAK,CAAC;EACnB,MAAMS,KAAA,GAAQT,IAAA,CAAK,CAAC;EACpB,MAAMU,IAAA,GAAOV,IAAA,CAAK,CAAC;EACnB,MAAMW,KAAA,GAAQX,IAAA,CAAK,CAAC;EAEpB,MAAMY,SAAA,GAAYF,IAAA,GAAOF,IAAA;EACzB,MAAMK,YAAA,GAAejB,aAAA,CAAcK,SAAA,EAAWE,OAAA,CAAQW,KAAA,EAAO,SAAS;EAEtE,MAAMC,UAAA,GAAaJ,KAAA,GAAQF,KAAA;EAC3B,MAAMO,aAAA,GAAgBpB,aAAA,CAAcM,UAAA,EAAYC,OAAA,CAAQW,KAAA,EAAO,SAAS;EAExE,MAAMG,OAAA,GAAUC,IAAA,CAAKC,KAAA,CAAMD,IAAA,CAAKE,GAAA,CAAIR,SAAS,IAAIC,YAAY;EAC7D,MAAMQ,IAAA,GAAOH,IAAA,CAAKC,KAAA,CAAMD,IAAA,CAAKE,GAAA,CAAIL,UAAU,IAAIC,aAAa;EAG5D,MAAMM,MAAA,IAAUV,SAAA,GAAYK,OAAA,GAAUJ,YAAA,IAAgB;EACtD,MAAMU,MAAA,IAAUR,UAAA,GAAaM,IAAA,GAAOL,aAAA,IAAiB;EAGrD,IAAIQ,QAAA,GAAWhB,IAAA,GAAOc,MAAA;EACtB,SAASG,MAAA,GAAS,GAAGA,MAAA,GAASR,OAAA,EAASQ,MAAA,IAAU;IAC/C,IAAIC,QAAA,GAAWjB,KAAA,GAAQc,MAAA;IACvB,SAASI,GAAA,GAAM,GAAGA,GAAA,GAAMN,IAAA,EAAMM,GAAA,IAAO;MACnC,MAAMC,QAAA,GAAW9B,OAAA,CACf,CACE,CACE,CAAC0B,QAAA,EAAUE,QAAQ,GACnB,CAACF,QAAA,EAAUE,QAAA,GAAWV,aAAa,GACnC,CAACQ,QAAA,GAAWX,YAAA,EAAca,QAAA,GAAWV,aAAa,GAClD,CAACQ,QAAA,GAAWX,YAAA,EAAca,QAAQ,GAClC,CAACF,QAAA,EAAUE,QAAQ,EACrB,CACF,EACAvB,OAAA,CAAQ0B,UACV;MACA,IAAI1B,OAAA,CAAQ2B,IAAA,EAAM;QAChB,IAAInC,SAAA,CAAUQ,OAAA,CAAQ2B,IAAA,EAAMF,QAAQ,GAAG;UACrCrB,OAAA,CAAQwB,IAAA,CAAKH,QAAQ;QACvB;MACF,OAAO;QACLrB,OAAA,CAAQwB,IAAA,CAAKH,QAAQ;MACvB;MAEAF,QAAA,IAAYV,aAAA;IACd;IACAQ,QAAA,IAAYX,YAAA;EACd;EACA,OAAOhB,iBAAA,CAAkBU,OAAO;AAClC;AAGA,IAAOyB,aAAA,GAAQjC,aAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}